{"aId": 1, "code": "public ScheduledExecutorService getExecutor() {\n        return executor;\n    }", "comment": " Returns the thread pool of this repository.", "issueId": "JCR-3066", "issueStringList": ["Use only one scheduler for repository tasks", "There are still a few Timer instances being used by Jackrabbit.", "It would be better if all tasks were scheduled by the central ScheduledExecutorService thread pool of the repository.", "Done in revision 1169801."], "SplitGT": [" Returns the thread pool of this repository."], "issueString": "Use only one scheduler for repository tasks\nThere are still a few Timer instances being used by Jackrabbit. It would be better if all tasks were scheduled by the central ScheduledExecutorService thread pool of the repository.\nDone in revision 1169801.\n"}
{"aId": 2, "code": "public final void startNamespaceContext(Map mappings) {\n        nsContext = new NamespaceContext(nsContext, mappings);\n    }", "comment": " Starts a local namespace context for the current XML element.", "issueId": "JCR-325", "issueStringList": ["docview roundtripping does not work with multivalue non-string properties", "when exporting a multivalue property with docview, the property values are serialized to a space delimited list in the xml attributes:", "for example:", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>", ".", ".", "<testNode", "jcr:primaryType=\"refTest\"", "refs=\"b5c12524-5446-4c1a-b024-77f623680271 7b4d4e6f-9515-47d8-a77c-b4beeaf469bc\"", ">", "the refTest nodetype was:", "[refTest]", "refs (reference) multiple", "importing this docview fails with: javax.jcr.ValueFormatException: not a valid UUID format", "this is due to the fact, that the space delimited list is not exploded anymore.", "actually this code is commented:", "org.apache.jackrabbit.core.xml.DocViewImportHandler, lines 191 - 200:", "*", "@todo should attribute value be interpreted as LIST type (i.e.", "multi-valued property)?", "String[] strings = Text.explode(attrValue, ' ', true);", "propValues = new Value[strings.length];", "for (int j = 0; j < strings.length; j++) {", "decode encoded blanks in value", "strings[j] = Text.replace(strings[j], \"_x0020_\", \" \");", "propValues[j] = InternalValue.create(strings[j]);", "}", "i haven't tested, but i assume this also fails for all other non-string property types.", "document view xml serialization is *not* guaranteed to be roundtrippable", "as some of the information, such as property type and multi-value flag, is lost.", "the only failsafe way of handling multi-valued properties is to skip them", "on export (see \"6.4.2.5 Multi-value Properties\",  jsr-170 specification).", "this is probably not desirable from a user perspective.", "the following pragmatic approach has been chosen to workaround this issue:", "document view export:", "multi-value properties are exported space-separated, with a leading line-feed (&#xa;)", "as a 'multi-valued'-hint; spaces within a value are encoded as _x0020_;", "e.g.", "[\"john doe\",\"donald duck\"] => \"&#xa;john_x0020_doe donald_x0020_duck\"", "single-value properties are exported without encoding contained spaces as _x0020_", "e.g.", "\"Hello, World!\"", "=> \"Hello, World!\"", "document view import:", "attribute values starting with &#xa; (line-feed) are assumed to represent multiple values,", "delimited by spaces; _x0020_ within values are decoded to spaces", "e.g.", "\"&#xa;john_x0020_doe donald_x0020_duck\" => [\"john doe\",\"donald duck\"]", "all other attribute values are considered to be single values; no space decoding", "is performed.", "e.g.", "\"Hello, World!\"", "=> \"Hello, World!\"", "fixed in svn r384197", "Couldn't this issue be handled more gracefully by postponing the space-splitting of the attribute value to when we have mapped the attribute name to a matching property definition?", "If the defined property is multivalued, then we'd split the attribute value and decode the _xFFFF_ endodings.", "Otherwise we'd just use the value as-is.", "Using a special marker character is a bit kludgy.", "the multi-value attribute is one of the differentiators being use to identify applicable property definitions.", "nt:unstructured for example defines 2 residual properties that only differ in the multi-value attribute.", "your approach would not be able to unambiguously determine the 'correct' definition because the", "'multi-valued' information is lost in document view .", "btw: i just realized that some related test-cases fail after my changes.", "i'll have to find out if they", "do so legitimatly or whether they have to be adapted.", "Stefan:", "> the multi-value attribute is one of the differentiators being use to identify applicable property definitions.", "> nt:unstructured for example defines 2 residual properties that only differ in the multi-value attribute.", "> your approach would not be able to unambiguously determine the 'correct' definition because the", "> 'multi-valued' information is lost in document view .", "You're right, but that's something I'd expect.", "If the property name matches both a single- and a multi-valued property and the property value doesn't hint the correct interpretation (like when a reference property contains a space), then it should be reasonable to default for the single-valued definition.", "We could even have some heuristics about the property value containing _xFFFF_ escapes when the correct property definition cannot otherwise be determined.", "This approach would cover the original case reported by Tobias as well as a majority of normal use cases.", "The solution with a marker character only works when doing import/export between Jackrabbit repositories, but fails when importing content from other sources like original XML documents, exports from other JCR implementations, or results of XSL transformations written based on the JCR spec.", "This solution also explicitly breaks the rules in section 6.4.2.5 of the JSR 170 spec.", "I'd use the following heuristic for interpreting the import of a document view property named N with value V:", "1) If N matches just a single property definition, interpret V according to that definition.", "2) Otherwise N matches a single-valued definition S and a multi-valued definition M:", "2.1) If V contains whitespace and S is not a string property definition, interpret V according to M", "2.2) If V contains _xFFFF_ escapes and M is not a string property definition, interpret V according to S", "2.2) If V contains _xFFFF_ escapes, interpret V according to M", "2.3) Otherwise interpret V according to S", "This heuristic doesn't match all cases, but should work pretty much as expected for a majority of use cases.", "Oops, I hade the sequence numbering wrong (added 2.2 after a bit of thought).", "The correct sequence is:", "1) If N matches just a single property definition, interpret V according to that definition.", "2) Otherwise N matches a single-valued definition S and a multi-valued definition M:", "2.1) If V contains whitespace and S is not a string property definition, interpret V according to M", "2.2) If V contains _xFFFF_ escapes and M is not a string property definition, interpret V according to S", "2.3) If V contains _xFFFF_ escapes, interpret V according to M", "2.4) Otherwise interpret V according to S", "Jukka:", "> This solution also explicitly breaks the rules in section 6.4.2.5 of the JSR 170 spec.", "you're right, i wasn't aware of that.", "btw the previous implementation (pre jcr-325 fix) was neither spec-compliant.", "until we've got a proper and spec-compliant solution for multi-value handling in document view", "i changed the current implementation to skip multi-valued properties entirely on document view export as", "this is explicitly allowed by the spec (svn r384850).", "document view serialization is per definition 'lossy' and not guaruanteed to roundtrip.", "changing type to 'Improvement' as current implementation (skipping mutli-valued properties on document view export) is compliant with \"6.4.2.5 Multi-value Properties\" of the spec.", "Assigned to me.", "I'm working on implementing the heuristics described above.", "I've gone through the importer code and come up with a plan on how to implement the interpretation described above.", "The current importer design makes it quite hard to postpone the value parsing decisions until the applicable property definitions are known, which effectively prevents form implementing the proposed heuristics.", "To make this easier and to simplify overall code I'd like to encapsulate the value parsing rules to the PropInfo instances so that the SessionImporter or WorkspaceImporter classes wouldn't need to know anything about where the values came from (sys view or doc view) and how they should be parsed.", "I could then create separate SysViewPropInfo and DocViewPropInfo subclasses to encapsulate the different value parsing rules of the system view and document view XML encodings.", "Doing this however requires quite extensive refactoring of the current code, so I'd like to get a confirmation on this plan before I proceed.", "The attached patch represents the first steps of this refactoring.", "Unless I've made a mistake, the patch doesn't yet change any of the existing behaviour (except for the location where some exceptions and log messages are generated), it just refactors the code structure so that it is easier to implement the SysViewPropInfo and DocViewPropInfo classes.", "The reason for publishing the patch at this point is to separate the structural changes from the behavioural changes and thus make the changes easier to review.", "I will continue with the behavioural changes if this structural change is approved.", "Below is a breakdown of the refactoring steps included in this patch.", "I did almost all of these changes using the automatic refactoring tools in Eclipse to minimize the chance of accidentally introducing errors in the code.", "The patched source also passes all unit tests and seems to import both system view and document view files just as before, which makes me quite confident in the quality of the refactoring.", "1) Move the following internal classes and interfaces to new files to make the class structure easier to manage:", "Importer.TextValue -> TextValue", "Importer.PropInfo -> PropInfo", "Importer.NodeInfo -> NodeInfo", "TargetImportHandler.AppendableValue -> AppendableValue", "TargetImportHandler.BufferedStringValue -> BufferedStringValue", "TargetImportHandler.StringValue -> StringValue", "2) Remove the NodeInfo and PropInfo setters and make the member fields \"private final\" to enforce their immutability", "3) Refactor the TargetImportHandler.disposePropertyValues(PropInfo) method into PropInfo.dispose() to improve encapsulation", "4) Move the AppendableValue.dispose() method up to TextValue and implement it as a null method in StringValue to avoid type casts in PropInfo.dispose()", "5) Remove the AppendableValue interface to make the class structure more simple as the SysViewImportHandler can just as well use the BufferedStringValue class directly", "6) Add a TextValue.getNamespaceContext() method and corresponding \"private final NamespaceResolver nsContext;\" fields in StringValue and BufferedStringValue to associate the value instances with the namespace context in which they should be parsed.", "Remove the \"nsContext\" argument from Importer.startNode() and use the TextValue.getNamespaceContext() method in SessionImporter and WorkspaceImporter to access the correct namespace context.", "7) Refactor the contents of the property iterator loop in WorkspaceImporter.startNode() into PropInfo.apply(NodeState, BatchedItemOperations, NodeTypeRegistry, ReferenceChangeTracker) and the contents of the similar loop in SessionImporter.startNode() into PropInfo.apply(NodeImpl, NamespaceResolver, ReferenceChangeTracker) to simplify the huge startNode() methods and to encapsulate the value parsing logic into PropInfo.", "This also allows the methods to easily share code through extracted getTargetType() and getApplicablePropertyDef() methods and enables other structural simplifications.", "8) Remove the now unneeded PropInfo getters.", "9) Refactor the contents of the value iterator loops in the PropInfo.apply() methods to TextValue.getValue(int type, NamespaceResolver resolver) and TextValue.getInternalValue(int type) methods and copy the implementation to StringValue and BufferedStringValue to increase encapsulation.", "In both cases the implementation can be simplified thanks to local access to the value details.", "10) Remove the length(), retrieve(), reader(), and getNamespaceContext() methods from the TextValue interface to ensure proper encapsulation.", "Those methods can also be fully removed from StringValue, but in BufferedStringValue they still have a purpose due to the more complex storage model.", "Refactor the JCR_MIXINTYPES branch in DocViewImportContentHandler to use TextValue.getValue() instead of StringValue.retrieve() to get the mixin type names.", "Overall these structural changes improve a number of quality metrics.", "The encapsulation level is higher, the method and class bodies are shorter, and even the total amount of code is slightly lower.", "i'm not sure regarding preserving the current (i.e.", "local, scoped) namespace context", "from the xml document within the StringValue & BufferedStringValue instances.", "in your patch you just pass a reference to the ns context in the constructor.", "the ns context however is mutable and could, theoretically at least, change", "after a *StringValue has been created and before getValue has been called.", "there should at least be a warning that the values have to be processed", "during the Importer.startNode call.", "ohterwise the ns context should be cloned.", "that however would significantly increase memory usage compared to the current approach.", "apart from this the patch looks good to me.", "> in your patch you just pass a reference to the ns context in the constructor.", "> the ns context however is mutable and could, theoretically at least, change", "> after a *StringValue has been created and before getValue has been called.", "Yes, I tought of this issue as well.", "The use of the ns context in the patch is temporally identical to the current code in svn, as the *StringValue instances are no longer used after the Importer.startNode() call.", "This temporal binding is however much less obvious in the patch, so you are right in that there is a threat of further changes breaking the inherent assumption of the ns context not changing during the lifetime of a *StringValue instance.", "This issue could be quite cleanly solved by explicitly managing the ns context as a stack of immutable prefix mappings instead of using the mutable SAX NamespaceSupport class.", "A namespace context would be an object with a reference to the parent namespace context and a collection of prefix mappings declared for a given XML element.", "Namespace resolution would then follow the parent references until a match is found.", "(This is actually what the NamespaceSupport class does internally, although it only presents a mutable facade that hides this data structure behind the push/pop methods.)", "I'll make a new version of the patch with modified namespace context handling.", "Attached a patch that contains the new namespace context implementation.", "The namespace-context.patch was made against the current SVN trunk and does not contain any of the other refactoring changes so it should be relatively easy to review.", "This change contains a lot more manual changes than the xml-refactoring.patch that was mostly tool-generated.", "I'm however again quite confident about the code quality, it passes all the unit tests and has no trouble handling convoluted XML documents like this:", "<foo xmlns=\"foo-ns\"><bar xmlns=\"bar-ns\"/></foo>", "The patch lets the ImportHandler class keep track of the startPrefixMapping calls per each XML element.", "These local prefix mappings are reported to the target handler using startNamespaceContext() before the related startElement() call.", "Similarly each endElement() call is followed by a endNamespaceContext() call.", "The TargetImportHandler class uses these namespace context calls to manage the local nsContext variable so that it always contains a reference to the immutable namespace context of the current XML element.", "Jukka:", "> Attached a patch that contains the new namespace context implementation.", "+1, looks good.", "thanks, jukka."], "SplitGT": [" Starts a local namespace context for the current XML element."], "issueString": "docview roundtripping does not work with multivalue non-string properties\nwhen exporting a multivalue property with docview, the property values are serialized to a space delimited list in the xml attributes:\nfor example:\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n.\n.\n<testNode \n    jcr:primaryType=\"refTest\" \n    refs=\"b5c12524-5446-4c1a-b024-77f623680271 7b4d4e6f-9515-47d8-a77c-b4beeaf469bc\"\n/>\n\nthe refTest nodetype was:\n\n[refTest] \n- refs (reference) multiple \n\nimporting this docview fails with: javax.jcr.ValueFormatException: not a valid UUID format\nthis is due to the fact, that the space delimited list is not exploded anymore. actually this code is commented:\n\norg.apache.jackrabbit.core.xml.DocViewImportHandler, lines 191 - 200:\n/*\n                // @todo should attribute value be interpreted as LIST type (i.e. multi-valued property)?\n                String[] strings = Text.explode(attrValue, ' ', true);\n                propValues = new Value[strings.length];\n                for (int j = 0; j < strings.length; j++) {\n                    // decode encoded blanks in value\n                    strings[j] = Text.replace(strings[j], \"_x0020_\", \" \");\n                    propValues[j] = InternalValue.create(strings[j]);\n                }\n*/\n\ni haven't tested, but i assume this also fails for all other non-string property types.\ndocument view xml serialization is *not* guaranteed to be roundtrippable\nas some of the information, such as property type and multi-value flag, is lost.\n\nthe only failsafe way of handling multi-valued properties is to skip them \non export (see \"6.4.2.5 Multi-value Properties\",  jsr-170 specification).\nthis is probably not desirable from a user perspective.\n\nthe following pragmatic approach has been chosen to workaround this issue:\n\ndocument view export:\n------------------------------\n\n- multi-value properties are exported space-separated, with a leading line-feed (&#xa;) \n  as a 'multi-valued'-hint; spaces within a value are encoded as _x0020_;\n\n  e.g. [\"john doe\",\"donald duck\"] => \"&#xa;john_x0020_doe donald_x0020_duck\"\n\n- single-value properties are exported without encoding contained spaces as _x0020_\n\n  e.g. \"Hello, World!\" => \"Hello, World!\"\n\n\ndocument view import:\n------------------------------\n\n- attribute values starting with &#xa; (line-feed) are assumed to represent multiple values,\n  delimited by spaces; _x0020_ within values are decoded to spaces\n\n  e.g. \"&#xa;john_x0020_doe donald_x0020_duck\" => [\"john doe\",\"donald duck\"]\n\n- all other attribute values are considered to be single values; no space decoding\n  is performed.\n\n  e.g. \"Hello, World!\" => \"Hello, World!\"\n\n\nfixed in svn r384197\nCouldn't this issue be handled more gracefully by postponing the space-splitting of the attribute value to when we have mapped the attribute name to a matching property definition? If the defined property is multivalued, then we'd split the attribute value and decode the _xFFFF_ endodings. Otherwise we'd just use the value as-is. Using a special marker character is a bit kludgy.\nthe multi-value attribute is one of the differentiators being use to identify applicable property definitions.\nnt:unstructured for example defines 2 residual properties that only differ in the multi-value attribute.\nyour approach would not be able to unambiguously determine the 'correct' definition because the \n'multi-valued' information is lost in document view .\n\nbtw: i just realized that some related test-cases fail after my changes. i'll have to find out if they \ndo so legitimatly or whether they have to be adapted.\nStefan:\n> the multi-value attribute is one of the differentiators being use to identify applicable property definitions.\n> nt:unstructured for example defines 2 residual properties that only differ in the multi-value attribute.\n> your approach would not be able to unambiguously determine the 'correct' definition because the\n> 'multi-valued' information is lost in document view .\n\nYou're right, but that's something I'd expect. If the property name matches both a single- and a multi-valued property and the property value doesn't hint the correct interpretation (like when a reference property contains a space), then it should be reasonable to default for the single-valued definition. We could even have some heuristics about the property value containing _xFFFF_ escapes when the correct property definition cannot otherwise be determined. This approach would cover the original case reported by Tobias as well as a majority of normal use cases.\n\nThe solution with a marker character only works when doing import/export between Jackrabbit repositories, but fails when importing content from other sources like original XML documents, exports from other JCR implementations, or results of XSL transformations written based on the JCR spec. This solution also explicitly breaks the rules in section 6.4.2.5 of the JSR 170 spec.\n\nI'd use the following heuristic for interpreting the import of a document view property named N with value V:\n\n   1) If N matches just a single property definition, interpret V according to that definition.\n   2) Otherwise N matches a single-valued definition S and a multi-valued definition M:\n      2.1) If V contains whitespace and S is not a string property definition, interpret V according to M\n      2.2) If V contains _xFFFF_ escapes and M is not a string property definition, interpret V according to S\n      2.2) If V contains _xFFFF_ escapes, interpret V according to M\n      2.3) Otherwise interpret V according to S\n\nThis heuristic doesn't match all cases, but should work pretty much as expected for a majority of use cases.\n\nOops, I hade the sequence numbering wrong (added 2.2 after a bit of thought). The correct sequence is:\n\n   1) If N matches just a single property definition, interpret V according to that definition.\n   2) Otherwise N matches a single-valued definition S and a multi-valued definition M:\n      2.1) If V contains whitespace and S is not a string property definition, interpret V according to M\n      2.2) If V contains _xFFFF_ escapes and M is not a string property definition, interpret V according to S\n      2.3) If V contains _xFFFF_ escapes, interpret V according to M\n      2.4) Otherwise interpret V according to S \nJukka:\n> This solution also explicitly breaks the rules in section 6.4.2.5 of the JSR 170 spec. \n\nyou're right, i wasn't aware of that.  btw the previous implementation (pre jcr-325 fix) was neither spec-compliant. \n\nuntil we've got a proper and spec-compliant solution for multi-value handling in document view \ni changed the current implementation to skip multi-valued properties entirely on document view export as\nthis is explicitly allowed by the spec (svn r384850).\n\n\n\ndocument view serialization is per definition 'lossy' and not guaruanteed to roundtrip.\n\nchanging type to 'Improvement' as current implementation (skipping mutli-valued properties on document view export) is compliant with \"6.4.2.5 Multi-value Properties\" of the spec.\nAssigned to me. I'm working on implementing the heuristics described above.\nI've gone through the importer code and come up with a plan on how to implement the interpretation described above. The current importer design makes it quite hard to postpone the value parsing decisions until the applicable property definitions are known, which effectively prevents form implementing the proposed heuristics. To make this easier and to simplify overall code I'd like to encapsulate the value parsing rules to the PropInfo instances so that the SessionImporter or WorkspaceImporter classes wouldn't need to know anything about where the values came from (sys view or doc view) and how they should be parsed. I could then create separate SysViewPropInfo and DocViewPropInfo subclasses to encapsulate the different value parsing rules of the system view and document view XML encodings. Doing this however requires quite extensive refactoring of the current code, so I'd like to get a confirmation on this plan before I proceed.\n\nThe attached patch represents the first steps of this refactoring. Unless I've made a mistake, the patch doesn't yet change any of the existing behaviour (except for the location where some exceptions and log messages are generated), it just refactors the code structure so that it is easier to implement the SysViewPropInfo and DocViewPropInfo classes. The reason for publishing the patch at this point is to separate the structural changes from the behavioural changes and thus make the changes easier to review. I will continue with the behavioural changes if this structural change is approved.\n\nBelow is a breakdown of the refactoring steps included in this patch. I did almost all of these changes using the automatic refactoring tools in Eclipse to minimize the chance of accidentally introducing errors in the code. The patched source also passes all unit tests and seems to import both system view and document view files just as before, which makes me quite confident in the quality of the refactoring.\n\n1) Move the following internal classes and interfaces to new files to make the class structure easier to manage:\n\n   * Importer.TextValue -> TextValue\n   * Importer.PropInfo -> PropInfo\n   * Importer.NodeInfo -> NodeInfo\n   * TargetImportHandler.AppendableValue -> AppendableValue\n   * TargetImportHandler.BufferedStringValue -> BufferedStringValue\n   * TargetImportHandler.StringValue -> StringValue\n\n2) Remove the NodeInfo and PropInfo setters and make the member fields \"private final\" to enforce their immutability\n\n3) Refactor the TargetImportHandler.disposePropertyValues(PropInfo) method into PropInfo.dispose() to improve encapsulation\n\n4) Move the AppendableValue.dispose() method up to TextValue and implement it as a null method in StringValue to avoid type casts in PropInfo.dispose()\n\n5) Remove the AppendableValue interface to make the class structure more simple as the SysViewImportHandler can just as well use the BufferedStringValue class directly\n\n6) Add a TextValue.getNamespaceContext() method and corresponding \"private final NamespaceResolver nsContext;\" fields in StringValue and BufferedStringValue to associate the value instances with the namespace context in which they should be parsed. Remove the \"nsContext\" argument from Importer.startNode() and use the TextValue.getNamespaceContext() method in SessionImporter and WorkspaceImporter to access the correct namespace context.\n\n7) Refactor the contents of the property iterator loop in WorkspaceImporter.startNode() into PropInfo.apply(NodeState, BatchedItemOperations, NodeTypeRegistry, ReferenceChangeTracker) and the contents of the similar loop in SessionImporter.startNode() into PropInfo.apply(NodeImpl, NamespaceResolver, ReferenceChangeTracker) to simplify the huge startNode() methods and to encapsulate the value parsing logic into PropInfo. This also allows the methods to easily share code through extracted getTargetType() and getApplicablePropertyDef() methods and enables other structural simplifications.\n\n8) Remove the now unneeded PropInfo getters.\n\n9) Refactor the contents of the value iterator loops in the PropInfo.apply() methods to TextValue.getValue(int type, NamespaceResolver resolver) and TextValue.getInternalValue(int type) methods and copy the implementation to StringValue and BufferedStringValue to increase encapsulation. In both cases the implementation can be simplified thanks to local access to the value details.\n\n10) Remove the length(), retrieve(), reader(), and getNamespaceContext() methods from the TextValue interface to ensure proper encapsulation. Those methods can also be fully removed from StringValue, but in BufferedStringValue they still have a purpose due to the more complex storage model. Refactor the JCR_MIXINTYPES branch in DocViewImportContentHandler to use TextValue.getValue() instead of StringValue.retrieve() to get the mixin type names.\n\nOverall these structural changes improve a number of quality metrics. The encapsulation level is higher, the method and class bodies are shorter, and even the total amount of code is slightly lower.\ni'm not sure regarding preserving the current (i.e. local, scoped) namespace context \nfrom the xml document within the StringValue & BufferedStringValue instances.\n\nin your patch you just pass a reference to the ns context in the constructor.\nthe ns context however is mutable and could, theoretically at least, change\nafter a *StringValue has been created and before getValue has been called.\n\nthere should at least be a warning that the values have to be processed\nduring the Importer.startNode call. ohterwise the ns context should be cloned. \nthat however would significantly increase memory usage compared to the current approach.\n\napart from this the patch looks good to me.\n> in your patch you just pass a reference to the ns context in the constructor.\n> the ns context however is mutable and could, theoretically at least, change\n> after a *StringValue has been created and before getValue has been called. \n\nYes, I tought of this issue as well. The use of the ns context in the patch is temporally identical to the current code in svn, as the *StringValue instances are no longer used after the Importer.startNode() call. This temporal binding is however much less obvious in the patch, so you are right in that there is a threat of further changes breaking the inherent assumption of the ns context not changing during the lifetime of a *StringValue instance.\n\nThis issue could be quite cleanly solved by explicitly managing the ns context as a stack of immutable prefix mappings instead of using the mutable SAX NamespaceSupport class. A namespace context would be an object with a reference to the parent namespace context and a collection of prefix mappings declared for a given XML element. Namespace resolution would then follow the parent references until a match is found. (This is actually what the NamespaceSupport class does internally, although it only presents a mutable facade that hides this data structure behind the push/pop methods.)\n\nI'll make a new version of the patch with modified namespace context handling.\nAttached a patch that contains the new namespace context implementation. The namespace-context.patch was made against the current SVN trunk and does not contain any of the other refactoring changes so it should be relatively easy to review.\n\nThis change contains a lot more manual changes than the xml-refactoring.patch that was mostly tool-generated. I'm however again quite confident about the code quality, it passes all the unit tests and has no trouble handling convoluted XML documents like this:\n\n    <foo xmlns=\"foo-ns\"><bar xmlns=\"bar-ns\"/></foo>\n\nThe patch lets the ImportHandler class keep track of the startPrefixMapping calls per each XML element. These local prefix mappings are reported to the target handler using startNamespaceContext() before the related startElement() call. Similarly each endElement() call is followed by a endNamespaceContext() call. The TargetImportHandler class uses these namespace context calls to manage the local nsContext variable so that it always contains a reference to the immutable namespace context of the current XML element.\nJukka:\n> Attached a patch that contains the new namespace context implementation. \n\n+1, looks good. thanks, jukka. \n"}
{"aId": 6, "code": "public static RepositoryConfig install(File xml, File dir)\n            throws IOException, ConfigurationException {\n        if (!dir.exists()) {\n            log.info(\"Creating repository directory {}\", dir);\n            dir.mkdirs();\n        }\n\n        if (!xml.exists()) {\n            log.info(\"Installing default repository configuration to {}\", xml);\n            OutputStream output = new FileOutputStream(xml);\n            try {\n                InputStream input =\n                    RepositoryImpl.class.getResourceAsStream(REPOSITORY_XML);\n                try {\n                    IOUtils.copy(input, output);\n                } finally {\n                   input.close();\n                }\n            } finally {\n                output.close();\n            }\n        }\n\n        return create(xml, dir);\n    }", "comment": " If the repository configuration file does not exist, then it is created using the default Jackrabbit configuration settings.", "issueId": "JCR-2119", "issueStringList": ["Method to create default RepositoryConfig from just the repository directory", "It would be useful to have a static method like RepositoryConfig.create(File) that would take the repository directory and expect to find the repository configuration in a \"repository.xml\" file inside that directory.", "If the directory does not exist, it would be created.", "And if the repository configuration file does not exist, then it would be created from the default configuration included in Jackrabbit.", "Added the following methods in revision 776310:", "RepositoryConfig.install(File dir);", "RepostiroyConfig.install(File xml, File dir);", "RepositoryConfig.create(File dir);", "RepositoryConfig.create(File xml, File dir);", "The install() methods will automatically create the repository directory and configuration file if they do not already exist.", "The create() methods will fail with an exception in the same situation."], "SplitGT": [" If the repository configuration file does not exist, then it is created using the default Jackrabbit configuration settings."], "issueString": "Method to create default RepositoryConfig from just the repository directory\nIt would be useful to have a static method like RepositoryConfig.create(File) that would take the repository directory and expect to find the repository configuration in a \"repository.xml\" file inside that directory.\n\nIf the directory does not exist, it would be created. And if the repository configuration file does not exist, then it would be created from the default configuration included in Jackrabbit.\nAdded the following methods in revision 776310:\n\n   RepositoryConfig.install(File dir);\n   RepostiroyConfig.install(File xml, File dir);\n   RepositoryConfig.create(File dir);\n   RepositoryConfig.create(File xml, File dir);\n\nThe install() methods will automatically create the repository directory and configuration file if they do not already exist. The create() methods will fail with an exception in the same situation.\n"}
{"aId": 7, "code": "public synchronized Connection getConnection() throws SQLException, RepositoryException {\n        if (isClosed) {\n            if (autoReconnect) {\n                reestablishConnection();\n            } else {\n                throw new SQLException(\"connection has been closed and autoReconnect == false\");\n            }\n        }\n        return connection;\n    }", "comment": " Gets the database connection that is managed.", "issueId": "JCR-940", "issueStringList": ["add db connection autoConnect for BundleDbPersistenceManager.", "Since bundled db pm doesn't inherited from database pm, it can't reconnect once database is bounced.", "it would be nice to add this feature.", "Here's a patch that adds reconnection logic to the bundle persistence managers.", "I've made an attempt to put this in a separate class such that it can be reused.", "I've tested it with MSSQL and with Oracle 10.", "Feedback is much appreciated!", "martijn, thanks for the patch.", "the patch looks very good in general, excellent job!", "i quickly browsed through the patch and i got a few comments:", "some changes in BundleDbPersistenceManager seem to have gone lost", "in your patch (e.g.", "#566985 & #563900).", "Oracle9PersistenceManager#storeBundle: the blob parameter is never set ;-)", "what was the reason for removing resetStatement(stmt) calls?", "(see e.g.", "PostgreSQLPersistenceManager line 120)", "tabs should be avoided in the source code", "cheers", "stefan", "Hi Stefan,", "Thanks for the feedback!", "I'll check out the lost changes you mention, and you're absolotely right on the blob parameter.", "The resetStatement calls are not removed but are now placed in the ConnectionRecoveryManager.executeStmt method.", "What do you think about letting Jackrabbit only return when a query succeeded (i.e., if the database connection is lost then Jackrabbit code retries until it succeeds)?", "I'll try to make a second version of the patch asap.", "Best regards,", "Martijn", "> What do you think about letting Jackrabbit only return when a query succeeded (i.e., if the database connection is lost then Jackrabbit code retries until it succeeds)?", "personally i don't think that this would be a good idea since JCR api calls could as a result block forever.", "one thing i forgot to mention: the new classes ConnectionRecoverable & ConnectionRecoveryManager would IMO be better placed in the o.a.j.core.persistence.util package (instead of o.a.j.core) .", "Hi Stefan,", "I'm preparing a new version of the patch.", "I see that #563900 belongs to JCR-1039, but where is #566385?", "Best regards,", "Martijn", "> Martijn Hendriks commented on JCR-940:", "> --------------------------------------", ">", "> Hi Stefan,", ">", "> I'm preparing a new version of the patch.", "I see that #563900 belongs to JCR-1039, but where is #566385?", "sorry, my mistake.", "it's #566985. it's just a trivial typo correction:", "http://svn.apache.org/viewvc?view=rev&revision=566985", "cheers", "stefan", ">", "> Best regards,", "> Martijn", "Hi,", "Here's a second version of the patch.", "Best regards,", "Martijn", "Hi,", "I have a few comments:", "SLEEP_BEFORE_RECONNECT = 10000;", "TRIALS = 1;", "I would use:", "SLEEP_BEFORE_RECONNECT = 500;", "TRIALS = 20;", "public synchronized boolean addStatement(String sql) {", "...", "log.warn(\"failed to add statement\");", "return false;", "}", "It's easy to forget checking the return value.", "Actually, you did _not_ check it.", "I would throw an exception if preparing a statement failed.", "initPreparedStatements: why not prepare the statements when they are first used?", "Like that you only prepare statements that are actually used.", "This saves time.", "So I would change:", "PreparedStatement stmt = (PreparedStatement) preparedStatements.get(sql);", "if (stmt == null) {", "throw new Exception(\"unknown SQL statement: \" + sql);", "}", "to", "PreparedStatement stmt = (PreparedStatement) preparedStatements.get(sql);", "if (stmt == null) {", "stmt = connection.prepareStatement(sql);", "preparedStatements.add(sql, stmt);", "}", "There is anyway a loop to reconnect if this failed.", "So you can get rid of addStatement(..), rePrepareStatements, and sqlStatements.", "+                        if (params[i] instanceof Long) {", "+                            stmt.setLong(i + 1, ((Long) params[i]).longValue());", "+                        } else if (params[i] instanceof byte[]) {", "+                            stmt.setBytes(i + 1, (byte[]) params[i]);", "+                        } else if (params[i] instanceof Blob) {", "+                            stmt.setBlob(i + 1, (Blob) params[i]);", "+                        } else {", "+                            stmt.setObject(i + 1, params[i]);", "Only the last line is required.", "close shared prepared statements", "This is not required.", "If the connection is closed, the prepared statements are closed.", "Just calling preparedStatements.clear() is enough.", "boolean reestablishConnection(..)", "Again, using a return value...", "private Set sqlStatements = new HashSet();", "stmt = con.prepareStatement(", "\"select NODE_ID, BUNDLE_DATA from \"", "+ schemaObjectPrefix + \"BUNDLE\");", "+                stmt = connectionManager.getConnection().prepareStatement(\"select NODE_ID, BUNDLE_DATA from BUNDLE\");", "The schemaObjectPrefix is lost here.", "> store: log.warn(\"storing and committing changes failed: \" + e.getMessage());", "exception stack traces must be logged as well:", "log.warn(\"storing and committing changes failed: \" + e.getMessage(), e);", "> stmt = connectionManager.getConnection().prepareStatement(\"select NODE_ID, BUNDLE_DATA from BUNDLE\");", "The SQL statement should stored in one of the member variables in my view (but it was also not done before...).", "+        if (!connectionManager.setAutoCommit(false)) {", "+            throw new ItemStateException(\"disabling autoCommit failed\");", "Using a return value for an exception.", "+            Object[] keys = getKey(bundle.getId().getUUID());", "+            Object[] params = new Object[keys.length + 1];", "+            params[0] = out.toByteArray();", "+            for (int i = 1; i < params.length; i++) {", "+                params[i] = keys[i-1];", "}", "What about using an ArrayList:", "List params = getKey(bundle.getId().getUUID());", "params.add(out.toByteArray());", "stmt.setBytes(2, bundle.getId().getUUID().getRawBytes());", "This is code you removed...", "Strange, how did this work with getStorageModel() != SM_BINARY_KEYS?", "+            Connection con = connectionManager.getConnection();", "+            if (con != null) {", "+                DatabaseMetaData metaData = con.getMetaData();", "+                if (metaData.getDriverMajorVersion() < 10) {", "+            Connection con = connectionManager.getConnection();", "+            if (con != null) {", "+                try {", "+                    con.rollback();", "In some places the return value is checked, in other places not.", "I would make sure getConnection never returns null, otherwise you get NullPointerExceptions in strange places, and you don't really know what was the reason.", "+    /**", "+     * @return the database connection that is managed, possibly null", "+     */", "+    public synchronized Connection getConnection() {", "+        int trials = TRIALS;", "+        while (trials-- > 0) {", "+", "+            // First, try to reconnect if needed", "+            if (isClosed && autoReconnect) {", "+                reestablishConnection();", "+            }", "+", "+            // Then, try to return the connection", "+            if (!isClosed) {", "+                return connection;", "+            }", "+        }", "+        log.warn(\"failed to get connection\");", "+        return null;", "+    }", "I would write:", "+    /**", "+     * @return the database connection that is managed, possibly null", "+     */", "+    public synchronized Connection getConnection() throws SQLException {", "+        // reconnect if needed", "+        if (isClosed && autoReconnect) {", "+            reestablishConnection();", "+        }", "+        return connection;", "+    }", "In my view, reestablishConnection should loop, and if it can't connect, throw an exception.", "And once it failed, it should set autoReconnect to false, otherwise other code will try to re-connect again and again (maybe endlessly).", "You have used reestablishConnection in many places in the code, I think it should only be called in one place.", "Thomas", "Hi Thomas,", "Thanks for your detailed comments!", "I'll take a good look at them when I have time (probably after the weekend) and prepare a third version.", "Martijn", "Hi Thomas,", "Here's a third version of the patch.", "Thanks for your useful comments: I think that they have improved it significantly.", "I also have added a \"blockOnConnectionLoss\" property that can be configured from the repository.xml (default value is false).", "Your last comment suggested to set autoReconnect to false after a failed reconnection attempt.", "I haven't included that because I have no idea who and when should set it to true again.", "Best regards,", "Martijn", "Hi,", "Great!", "The patch looks very good!", "I will apply it in my environment, test it, and then commit it.", "The 'blockOnConnectionLoss' feature is OK, what is your use case?", "Just one remark: currently SLEEP_BEFORE_RECONNECT is 0.5 seconds, that's great because re-creating a TCP/IP connection usually is quick, no need to wait many seconds before the first re-try (if we expect MySQL to be the 'customer' for this feature).", "Currently TRIALS is 2, that means giving up after at most 1 second.", "I think that's a bit short.", "What about setting TRIALS to 10?", "It will then try at most 5 seconds, enough for a unstable wireless connection (not sure if this is a use case).", "Thomas", "> Great!", "The patch looks very good!", "Thanks!", "> I will apply it in my environment, test it, and then commit it.", "The 'blockOnConnectionLoss' feature is OK, what is your use case?", "Just one remark:", "Our application caches query results that we know to be stable.", "If some nodes in the result set of such a query are not yet in the Jackrabbit caches and the connection is lost, then they are skipped in the NodeIterator for the queries result.", "I.e., our caches could get out-of-sync when the connection is lost, which would require a restart.", "Blocking within Jackrabbit solves this transparently, and this patch makes a first attempt at that.", "Currently one statement/changelog fails before blocking, i.e.", "that statement/changelog is lost, so with very bad luck our caches could still get out of sync.", "I'm still thinking on how to block on this first statement/changelog in an elegant way.", "Of course, we get a lot of contention, but that would - in theory be resolved - when the connection comes up again.", "> Currently TRIALS is 2, that means giving up after at most 1 second.", "I think that's a bit short.", "What about setting TRIALS to 10?", "It will then try at", "> most 5 seconds, enough for a unstable wireless connection (not sure if this is a use case).", "Yes, 10 is fine.", "Martijn", "I have run the unit tests with this patch, and that works.", "I wanted to test if auto-reconnect works using PostgreSQL on a remote machine.", "Unfortunately it is quite complex to enable remote connections in PostgreSQL (you need to change pg_hba.conf and postgresql.conf, the GUI doesn't really work), and I was not fully successful: Remote connections still don't work, except if I use a TCP/IP redirect utility (actually one I made myself some time ago).", "But this is very slow.", "I tried out auto-reconnect (remove network cable), but I found some problems: Unlike the regular DatabasePersistenceManager, BundleDbPersistenceManager.store doesn't try to re-connect:", "void store(ChangeLog changeLog) {", "..", "connectionManager.setAutoReconnect(false);", "super.store(changeLog);", "..", "}", "So the feature still needs to be improved and tested more.", "But the patch doesn't seem to break anything, so I will commit it shortly.", "Thomas", "Revision 575734: BundleDbPersistenceManager auto-reconnect", "I have implemented the loop BundleDbPersistenceManager.store(ChangeLog), but unfortunately the feature still doesn't work always in the following case:", "enabling 'blockOnConnectionLoss'", "run mvn install", "stop the database server (for example PostgreSQL) while the test runs", "start the database server", "Sometimes the SQLException is thrown, and the test fails.", "This needs to be tested some more.", "Hi Thomas,", "I think that besides the BundleDbPM.store method the ConnectionrecoveryManager.execute* methods also need to be wrapped by a retry-loop.", "I've patched this locally and want to execute the unit tests using the MSSQL bundle PM.", "I'm not familiar with the test harness...how should I do this?", "Some initial attempts to alter the repository.xml and workspace.xmls in the jackrabbit-core\\applications\\test directory failed.", "Here's a cumulative patch that wraps the ConnectionRecoveryManager.execute* methods and the BundleDbPM.store method in a retry loop.", "I tested this using the unit tests with a remote MSSQL database.", "The blockOnConnectionLoss=true option now seems to work as expected: all tests still pass when the network cable is unplugged one or more times during the tests.", "Sorry, I have attached my comments to the wrong bug (JCR-1138).", "Hi,", "The patch looks good.", "I tried with PostgreSQL and got this problem:", "ConnectionRecoveryManager: could not setup connection, reason: could not load driver: org.postgresql.Driver, state/code: null/0", "(ConnectionRecoveryManager.java, line 430)", "ConnectionRecoveryManager: blocking until database connection is up again...", "(ConnectionRecoveryManager.java, line 368)", "Do you agree that retry doesn't make sense if the driver could not be loaded?", "If yes I will change the code.", "Also, it would probably make sense to write the database URL and the user name (not the password) to the log file, so the person (alias poor guy) who has to start the database knows which one and can test the connection using some other tool.", "If that's OK with you, I will make it throw a RepositoryException if the database driver could not be loaded or initialized (ExceptionInInitializerError):", "private void setupConnection() throws SQLException, RepositoryException {", "try {", "Class driverClass = Class.forName(driver);", "Workaround for Apache Derby:", "The JDBC specification recommends the Class.ForName method without the .newInstance() method call,", "but adding the newInstance() guarantees that Derby will be booted on any Java Virtual Machine.", "driverClass.newInstance();", "} catch (Throwable e) {", "throw new RepositoryException(\"Could not load or initialize the database driver class \" + driver, e);", "}", "Revision 578043: apply patch submitted by Martijn Hendriks (plus RepositoryException if the driver could not be loaded).", "> Do you agree that retry doesn't make sense if the driver could not be loaded?", "Yes, good point!", "> If yes I will change the code.", "Also, it would probably make sense to write the database URL and the user name (not the password) to the log file, so", "> the person (alias poor guy) who has to start the database knows which one and can test the connection using some other tool.", "Yes, that's more informative than the current situation.", "It seems to work now.", "Please re-open or create a new bug if not."], "SplitGT": [" Gets the database connection that is managed."], "issueString": "add db connection autoConnect for BundleDbPersistenceManager.\nSince bundled db pm doesn't inherited from database pm, it can't reconnect once database is bounced. it would be nice to add this feature. \nHere's a patch that adds reconnection logic to the bundle persistence managers. I've made an attempt to put this in a separate class such that it can be reused. I've tested it with MSSQL and with Oracle 10. Feedback is much appreciated!\nmartijn, thanks for the patch. the patch looks very good in general, excellent job!\n\ni quickly browsed through the patch and i got a few comments:\n\n- some changes in BundleDbPersistenceManager seem to have gone lost\n   in your patch (e.g. #566985 & #563900). \n\n- Oracle9PersistenceManager#storeBundle: the blob parameter is never set ;-)\n\n- what was the reason for removing resetStatement(stmt) calls? \n  (see e.g. PostgreSQLPersistenceManager line 120)\n\n- tabs should be avoided in the source code\n\ncheers\nstefan\nHi Stefan,\n\nThanks for the feedback! I'll check out the lost changes you mention, and you're absolotely right on the blob parameter. The resetStatement calls are not removed but are now placed in the ConnectionRecoveryManager.executeStmt method.\n\nWhat do you think about letting Jackrabbit only return when a query succeeded (i.e., if the database connection is lost then Jackrabbit code retries until it succeeds)?\n\nI'll try to make a second version of the patch asap.\n\nBest regards,\n\nMartijn\n> What do you think about letting Jackrabbit only return when a query succeeded (i.e., if the database connection is lost then Jackrabbit code retries until it succeeds)?\n\npersonally i don't think that this would be a good idea since JCR api calls could as a result block forever.\none thing i forgot to mention: the new classes ConnectionRecoverable & ConnectionRecoveryManager would IMO be better placed in the o.a.j.core.persistence.util package (instead of o.a.j.core) .\nHi Stefan,\n\nI'm preparing a new version of the patch. I see that #563900 belongs to JCR-1039, but where is #566385?\n\nBest regards,\nMartijn\n> Martijn Hendriks commented on JCR-940:\n> --------------------------------------\n> \n> Hi Stefan,\n> \n> I'm preparing a new version of the patch. I see that #563900 belongs to JCR-1039, but where is #566385?\n\nsorry, my mistake. it's #566985. it's just a trivial typo correction:\n\nhttp://svn.apache.org/viewvc?view=rev&revision=566985\n\ncheers\nstefan\n\n> \n> Best regards,\n> Martijn\n\n\nHi,\n\nHere's a second version of the patch.\n\nBest regards,\n\nMartijn\nHi,\nI have a few comments:\n\nSLEEP_BEFORE_RECONNECT = 10000;\nTRIALS = 1;\nI would use:\nSLEEP_BEFORE_RECONNECT = 500;\nTRIALS = 20;\n\npublic synchronized boolean addStatement(String sql) {\n...\n        log.warn(\"failed to add statement\");\n        return false;\n    }\n\nIt's easy to forget checking the return value. Actually, you did _not_ check it.\nI would throw an exception if preparing a statement failed.\n\ninitPreparedStatements: why not prepare the statements when they are first used?\nLike that you only prepare statements that are actually used. This saves time. So I would change:\n\nPreparedStatement stmt = (PreparedStatement) preparedStatements.get(sql);\nif (stmt == null) {\n  throw new Exception(\"unknown SQL statement: \" + sql);\n}\n\nto\n\nPreparedStatement stmt = (PreparedStatement) preparedStatements.get(sql);\nif (stmt == null) {\n  stmt = connection.prepareStatement(sql);\n  preparedStatements.add(sql, stmt);\n}\n\nThere is anyway a loop to reconnect if this failed. So you can get rid of addStatement(..), rePrepareStatements, and sqlStatements.\n\n+                        if (params[i] instanceof Long) {\n+                            stmt.setLong(i + 1, ((Long) params[i]).longValue());\n+                        } else if (params[i] instanceof byte[]) {\n+                            stmt.setBytes(i + 1, (byte[]) params[i]);\n+                        } else if (params[i] instanceof Blob) {\n+                            stmt.setBlob(i + 1, (Blob) params[i]);\n+                        } else {\n+                            stmt.setObject(i + 1, params[i]);\n\nOnly the last line is required.\n\n// close shared prepared statements\n\nThis is not required. If the connection is closed, the prepared statements are closed. Just calling preparedStatements.clear() is enough.\n\nboolean reestablishConnection(..)\n\nAgain, using a return value...\n\n\nprivate Set sqlStatements = new HashSet();\n\n\n-                stmt = con.prepareStatement(\n-                        \"select NODE_ID, BUNDLE_DATA from \"\n-                        + schemaObjectPrefix + \"BUNDLE\");\n+                stmt = connectionManager.getConnection().prepareStatement(\"select NODE_ID, BUNDLE_DATA from BUNDLE\");\n\nThe schemaObjectPrefix is lost here.\n\n> store: log.warn(\"storing and committing changes failed: \" + e.getMessage());\n\nexception stack traces must be logged as well:\n\nlog.warn(\"storing and committing changes failed: \" + e.getMessage(), e);\n\n> stmt = connectionManager.getConnection().prepareStatement(\"select NODE_ID, BUNDLE_DATA from BUNDLE\");\n\nThe SQL statement should stored in one of the member variables in my view (but it was also not done before...).\n\n+        if (!connectionManager.setAutoCommit(false)) {\n+            throw new ItemStateException(\"disabling autoCommit failed\");\n\nUsing a return value for an exception.\n\n+            Object[] keys = getKey(bundle.getId().getUUID());\n+            Object[] params = new Object[keys.length + 1];\n+            params[0] = out.toByteArray();\n+            for (int i = 1; i < params.length; i++) {\n+                params[i] = keys[i-1];\n             }\n\nWhat about using an ArrayList:\nList params = getKey(bundle.getId().getUUID());\nparams.add(out.toByteArray());\n\n-            stmt.setBytes(2, bundle.getId().getUUID().getRawBytes());\nThis is code you removed... Strange, how did this work with getStorageModel() != SM_BINARY_KEYS?\n\n+            Connection con = connectionManager.getConnection();\n+            if (con != null) {\n+                DatabaseMetaData metaData = con.getMetaData();\n+                if (metaData.getDriverMajorVersion() < 10) {\n\n+            Connection con = connectionManager.getConnection();\n+            if (con != null) {\n+                try {\n+                    con.rollback();\n\nIn some places the return value is checked, in other places not. I would make sure getConnection never returns null, otherwise you get NullPointerExceptions in strange places, and you don't really know what was the reason.\n\n+    /**\n+     * @return the database connection that is managed, possibly null\n+     */\n+    public synchronized Connection getConnection() {\n+        int trials = TRIALS;\n+        while (trials-- > 0) {\n+\n+            // First, try to reconnect if needed\n+            if (isClosed && autoReconnect) {\n+                reestablishConnection();\n+            }\n+\n+            // Then, try to return the connection\n+            if (!isClosed) {\n+                return connection;\n+            }\n+        }\n+        log.warn(\"failed to get connection\");\n+        return null;\n+    }\n\nI would write:\n\n+    /**\n+     * @return the database connection that is managed, possibly null\n+     */\n+    public synchronized Connection getConnection() throws SQLException {\n+        // reconnect if needed\n+        if (isClosed && autoReconnect) {\n+            reestablishConnection();\n+        }\n+        return connection;\n+    }\n\nIn my view, reestablishConnection should loop, and if it can't connect, throw an exception. And once it failed, it should set autoReconnect to false, otherwise other code will try to re-connect again and again (maybe endlessly). You have used reestablishConnection in many places in the code, I think it should only be called in one place.\n\nThomas\n\nHi Thomas,\n\nThanks for your detailed comments! I'll take a good look at them when I have time (probably after the weekend) and prepare a third version.\n\nMartijn\nHi Thomas,\n\nHere's a third version of the patch. Thanks for your useful comments: I think that they have improved it significantly. I also have added a \"blockOnConnectionLoss\" property that can be configured from the repository.xml (default value is false).\n\nYour last comment suggested to set autoReconnect to false after a failed reconnection attempt. I haven't included that because I have no idea who and when should set it to true again.\n\nBest regards,\n\nMartijn\nHi,\n\nGreat! The patch looks very good! \n\nI will apply it in my environment, test it, and then commit it. The 'blockOnConnectionLoss' feature is OK, what is your use case? Just one remark: currently SLEEP_BEFORE_RECONNECT is 0.5 seconds, that's great because re-creating a TCP/IP connection usually is quick, no need to wait many seconds before the first re-try (if we expect MySQL to be the 'customer' for this feature). \n\nCurrently TRIALS is 2, that means giving up after at most 1 second. I think that's a bit short. What about setting TRIALS to 10? It will then try at most 5 seconds, enough for a unstable wireless connection (not sure if this is a use case).\n\nThomas\n> Great! The patch looks very good!\nThanks!\n\n> I will apply it in my environment, test it, and then commit it. The 'blockOnConnectionLoss' feature is OK, what is your use case? Just one remark: \n\nOur application caches query results that we know to be stable. If some nodes in the result set of such a query are not yet in the Jackrabbit caches and the connection is lost, then they are skipped in the NodeIterator for the queries result. I.e., our caches could get out-of-sync when the connection is lost, which would require a restart. Blocking within Jackrabbit solves this transparently, and this patch makes a first attempt at that. Currently one statement/changelog fails before blocking, i.e. that statement/changelog is lost, so with very bad luck our caches could still get out of sync. I'm still thinking on how to block on this first statement/changelog in an elegant way. Of course, we get a lot of contention, but that would - in theory be resolved - when the connection comes up again.\n\n> Currently TRIALS is 2, that means giving up after at most 1 second. I think that's a bit short. What about setting TRIALS to 10? It will then try at\n> most 5 seconds, enough for a unstable wireless connection (not sure if this is a use case).\n\nYes, 10 is fine.\n\nMartijn\nI have run the unit tests with this patch, and that works.\n\nI wanted to test if auto-reconnect works using PostgreSQL on a remote machine. Unfortunately it is quite complex to enable remote connections in PostgreSQL (you need to change pg_hba.conf and postgresql.conf, the GUI doesn't really work), and I was not fully successful: Remote connections still don't work, except if I use a TCP/IP redirect utility (actually one I made myself some time ago). But this is very slow.\n\nI tried out auto-reconnect (remove network cable), but I found some problems: Unlike the regular DatabasePersistenceManager, BundleDbPersistenceManager.store doesn't try to re-connect:\n\nvoid store(ChangeLog changeLog) {\n  ..\n  connectionManager.setAutoReconnect(false);\n  super.store(changeLog);\n  ..\n}\n\nSo the feature still needs to be improved and tested more.\nBut the patch doesn't seem to break anything, so I will commit it shortly.\n\nThomas\nRevision 575734: BundleDbPersistenceManager auto-reconnect\nI have implemented the loop BundleDbPersistenceManager.store(ChangeLog), but unfortunately the feature still doesn't work always in the following case:\n- enabling 'blockOnConnectionLoss'\n- run mvn install\n- stop the database server (for example PostgreSQL) while the test runs\n- start the database server\nSometimes the SQLException is thrown, and the test fails.\nThis needs to be tested some more.\nHi Thomas,\n\nI think that besides the BundleDbPM.store method the ConnectionrecoveryManager.execute* methods also need to be wrapped by a retry-loop. I've patched this locally and want to execute the unit tests using the MSSQL bundle PM. I'm not familiar with the test harness...how should I do this? Some initial attempts to alter the repository.xml and workspace.xmls in the jackrabbit-core\\applications\\test directory failed.\nHere's a cumulative patch that wraps the ConnectionRecoveryManager.execute* methods and the BundleDbPM.store method in a retry loop.\n\nI tested this using the unit tests with a remote MSSQL database. The blockOnConnectionLoss=true option now seems to work as expected: all tests still pass when the network cable is unplugged one or more times during the tests.\nSorry, I have attached my comments to the wrong bug (JCR-1138).\n\nHi,\n\nThe patch looks good. I tried with PostgreSQL and got this problem:\n\nConnectionRecoveryManager: could not setup connection, reason: could not load driver: org.postgresql.Driver, state/code: null/0\n(ConnectionRecoveryManager.java, line 430)\nConnectionRecoveryManager: blocking until database connection is up again...\n(ConnectionRecoveryManager.java, line 368)\n\nDo you agree that retry doesn't make sense if the driver could not be loaded? If yes I will change the code. Also, it would probably make sense to write the database URL and the user name (not the password) to the log file, so the person (alias poor guy) who has to start the database knows which one and can test the connection using some other tool.\n\nIf that's OK with you, I will make it throw a RepositoryException if the database driver could not be loaded or initialized (ExceptionInInitializerError):\n\n    private void setupConnection() throws SQLException, RepositoryException {\n        try {\n            Class driverClass = Class.forName(driver);\n            // Workaround for Apache Derby:\n            // The JDBC specification recommends the Class.ForName method without the .newInstance() method call,\n            // but adding the newInstance() guarantees that Derby will be booted on any Java Virtual Machine.\n            driverClass.newInstance();\n        } catch (Throwable e) {\n            throw new RepositoryException(\"Could not load or initialize the database driver class \" + driver, e);\n        }\n\n\nRevision 578043: apply patch submitted by Martijn Hendriks (plus RepositoryException if the driver could not be loaded).\n> Do you agree that retry doesn't make sense if the driver could not be loaded?\n\nYes, good point!\n\n> If yes I will change the code. Also, it would probably make sense to write the database URL and the user name (not the password) to the log file, so\n> the person (alias poor guy) who has to start the database knows which one and can test the connection using some other tool.\n\nYes, that's more informative than the current situation.\n\n\n\nIt seems to work now. Please re-open or create a new bug if not.\n"}
{"aId": 12, "code": "public static Connection getConnection(String driver, String url,\n            String user, String password) throws RepositoryException,\n            SQLException {\n        if (driver != null || driver.length() > 0) {\n            try {\n                Class d = Class.forName(driver);\n                if (javax.naming.Context.class.isAssignableFrom(d)) {\n                    // JNDI context\n                    Context context = (Context) d.newInstance();\n                    DataSource ds = (DataSource) context.lookup(url);\n                    return ds.getConnection(user, password);\n                } else {\n                    try {\n                        // Workaround for Apache Derby:\n                        // The JDBC specification recommends the Class.forName method without the .newInstance() method call, \n                        // but it is required after a Derby 'shutdown'.\n                        d.newInstance();\n                    } catch (Throwable e) {\n                        // Ignore exceptions\n                        // There's no requirement that a JDBC driver class has a public default constructor\n                    }\n                }\n            } catch (ClassNotFoundException e) {\n                throw new RepositoryException(\"Could not load class \" + driver, e);\n            } catch (InstantiationException e) {\n                throw new RepositoryException(\"Could not instantiate context \" + driver, e);\n            } catch (IllegalAccessException e) {\n                throw new RepositoryException(\"Could not instantiate context \" + driver, e);\n            } catch (NamingException e) {\n                throw new RepositoryException(\"Naming exception using \" + driver + \" url: \" + url, e);\n            }\n        }\n        return DriverManager.getConnection(url, user, password);\n    }", "comment": " To do that, the driver class name must reference a javax.naming.Context class (for example javax.naming.InitialContext), and the URL must be the JNDI URL (for example java:comp/env/jdbc/Test).", "issueId": "JCR-948", "issueStringList": ["Support for JNDI configuration of BundleDbPersistenceManager", "It would be nice to have the option to configure BundleDbPersistenceManager database specifying a JNDI name of a DataSource.", "Attached patch proposal.", "Connection initialization code extracted to initConnection method.", "You can configure BundleDbPersistenceManager to use JNDI data source by setting dataSourceLocation parameter, otherwise previous way is used.", "+1 to applying the patch (preferably with spaces instead of tabs for indentation and without unnecessarily rearranging the imports)", "My patch solves the problem not only for BundleDbPersistenceManager, but also for the DbDataStore.", "I suggest to use the same mechanism for all modules that require a connection.", "In this patch, no new property is required, instead the existing driver and url properties are used: To use JNDI, the driver class name must reference a javax.naming.Context class (for example javax.naming.InitialContext), and the URL must be the JNDI URL (for example java:comp/env/jdbc/Test).", "If nobody objects, I will check in this patch in a few days.", "Nice, I like it!", "Comments:", "It's better if you commit the typo fixes to MySQL and Oracle persistence managers in a separate \"typos\" revision", "Even though it's not strictly related, I'd wrap the Derby workaround d.newInstance() into a try-catch block that simply ignores all exceptions.", "AFAIK there's no requirement that a JDBC driver class has a public default constructor.", "Resolved in revision 599371"], "SplitGT": [" To do that, the driver class name must reference a javax.naming.Context class (for example javax.naming.InitialContext), and the URL must be the JNDI URL (for example java:comp/env/jdbc/Test)."], "issueString": "Support for JNDI configuration of BundleDbPersistenceManager\nIt would be nice to have the option to configure BundleDbPersistenceManager database specifying a JNDI name of a DataSource.\nAttached patch proposal. Connection initialization code extracted to initConnection method.\n\nYou can configure BundleDbPersistenceManager to use JNDI data source by setting dataSourceLocation parameter, otherwise previous way is used.\n+1 to applying the patch (preferably with spaces instead of tabs for indentation and without unnecessarily rearranging the imports)\nMy patch solves the problem not only for BundleDbPersistenceManager, but also for the DbDataStore. I suggest to use the same mechanism for all modules that require a connection.\n\nIn this patch, no new property is required, instead the existing driver and url properties are used: To use JNDI, the driver class name must reference a javax.naming.Context class (for example javax.naming.InitialContext), and the URL must be the JNDI URL (for example java:comp/env/jdbc/Test).\n\nIf nobody objects, I will check in this patch in a few days.\nNice, I like it!\n\nComments:\n\n* It's better if you commit the typo fixes to MySQL and Oracle persistence managers in a separate \"typos\" revision\n\n* Even though it's not strictly related, I'd wrap the Derby workaround d.newInstance() into a try-catch block that simply ignores all exceptions. AFAIK there's no requirement that a JDBC driver class has a public default constructor.\nResolved in revision 599371\n"}
{"aId": 15, "code": "public synchronized void registerNodeTypes(Collection newNTDefs)\n            throws InvalidNodeTypeDefException, RepositoryException {\n        // exceptions that might be thrown by internalRegister(Collection)\n        RepositoryException re = null;\n        InvalidNodeTypeDefException intde = null;\n\n        try {\n            internalRegister(newNTDefs);\n        } catch (RepositoryException e) {\n            // store exception so it can be re-thrown later on\n            re = e;\n        } catch (InvalidNodeTypeDefException e) {\n            // store exception so it can be re-thrown later on\n            intde = e;\n        }\n        boolean allNodeTypeDefsAreValid = re == null && intde == null;\n        if (allNodeTypeDefsAreValid) {\n            Iterator validNTDsIterator = newNTDefs.iterator();\n            while (validNTDsIterator.hasNext()) {\n                NodeTypeDef ntd = (NodeTypeDef) validNTDsIterator.next();\n                // store property & child node definitions of new node type by id\n                customNTDefs.add(ntd);\n            }\n            persistCustomNodeTypeDefs(customNTDefs);\n            // notify listeners\n            for (Iterator iter = newNTDefs.iterator(); iter.hasNext();) {\n                NodeTypeDef ntDef = (NodeTypeDef) iter.next();\n                notifyRegistered(ntDef.getName());\n            }\n        } else {\n            // re-throw the exception\n            if (re != null) {\n                throw re;\n            } else if (intde != null) {\n                throw intde;\n            }\n        }\n    }", "comment": " Note that in the case an exception is thrown, some node types might have been nevertheless successfully registered.", "issueId": "JCR-274", "issueStringList": ["NodeTypeRegistry.registerNodetypes(Collection) should not register a partial set", "the javadoc says:", "Note that in the case an exception is thrown, some node types might have", "been nevertheless successfully registered.", "the problem hereby is, that it cannot be determined easily, what nodetypes could be registered, and which couldnt.", "i would rather prefer a all-or-nothing behaviour.", "Tagged for 1.0", "o The registration of the internal node types at start up of the repository is left as it is, as good as possible.", "o The creation of the effective node types is left as it is, as good as possible.", "o The patch adds a cloned EffectiveNodeTypeCache object and a cloned map of registered NodeTypeDefs to the context of the node type registration.", "All node type definitions specified in the registerNodeTypes(Collection) method call are temporarily added to this map of registered NodeTypeDefs.", "The validation of the node types uses the registration context and therefore also considers all new node types no matter if they are", "cyclic dependend like the one this issue is about.", "Stefans nice checks for circular node auto creation and circular inheritance should still work.", "Only if all node types definitions are valid and all node types could be created they are finally added to the repository.", "A failed validation or registration does not effect the repository.", "That also fixes JCR-274.", "Thank you Stefan, for the support behind the scenes.", "As it is not yet possible to unregister node types this test is just for a one time use.", "My first comment assumes to be posted in JCR-273 not in this issue :-/"], "SplitGT": [" Note that in the case an exception is thrown, some node types might have been nevertheless successfully registered."], "issueString": "NodeTypeRegistry.registerNodetypes(Collection) should not register a partial set\nthe javadoc says:\n\n     * Note that in the case an exception is thrown, some node types might have\n     * been nevertheless successfully registered.\n\nthe problem hereby is, that it cannot be determined easily, what nodetypes could be registered, and which couldnt. i would rather prefer a all-or-nothing behaviour.\nTagged for 1.0\n\no The registration of the internal node types at start up of the repository is left as it is, as good as possible.\no The creation of the effective node types is left as it is, as good as possible.\no The patch adds a cloned EffectiveNodeTypeCache object and a cloned map of registered NodeTypeDefs to the context of the node type registration.\nAll node type definitions specified in the registerNodeTypes(Collection) method call are temporarily added to this map of registered NodeTypeDefs.\nThe validation of the node types uses the registration context and therefore also considers all new node types no matter if they are\ncyclic dependend like the one this issue is about. Stefans nice checks for circular node auto creation and circular inheritance should still work.\nOnly if all node types definitions are valid and all node types could be created they are finally added to the repository. \nA failed validation or registration does not effect the repository.\nThat also fixes JCR-274.\nThank you Stefan, for the support behind the scenes.\n\nAs it is not yet possible to unregister node types this test is just for a one time use. \nMy first comment assumes to be posted in JCR-273 not in this issue :-/ \n"}
{"aId": 18, "code": "public synchronized Session login(Credentials credentials, String workspaceName)\n            throws RepositoryException {\n        // Start the repository if this is the first login\n        if (sessions.isEmpty()) {\n            startRepository();\n        }\n\n        try {\n            logger.debug(\"Opening a new session\");\n            Session session = repository.login(credentials, workspaceName);\n            sessions.add(session);\n            ((SessionImpl) session).addListener(this);\n            logger.info(\"Session opened\");\n\n            return session;\n        } finally {\n            // Stop the repository if the login failed\n            // and no other sessions are active\n            if (sessions.isEmpty()) {\n                stopRepository();\n            }\n        }\n    }", "comment": " Initializes the underlying repository instance if needed.", "issueId": "JCR-353", "issueStringList": ["TransientRepository does not shutdown if first login fails", "The TransientRepository.login() method initializes the underlying repository when it is first called (initially or after the repository has previously been shut down) bug doesn't shut down the initialized repository if the login fails.", "If the application then decides to exit or otherwise not start another session, then the repository remains in an initialized state with no active sessions.", "This issue should be fixed by properly handling login failures in the TransientRepository.login() method."], "SplitGT": [" Initializes the underlying repository instance if needed."], "issueString": "TransientRepository does not shutdown if first login fails\nThe TransientRepository.login() method initializes the underlying repository when it is first called (initially or after the repository has previously been shut down) bug doesn't shut down the initialized repository if the login fails. If the application then decides to exit or otherwise not start another session, then the repository remains in an initialized state with no active sessions.\n\nThis issue should be fixed by properly handling login failures in the TransientRepository.login() method.\n"}
{"aId": 26, "code": "public int getMaxExtractLength() {\n        return maxExtractLength;\n    }", "comment": " Returns the maximum number of characters to extract from binaries.", "issueId": "JCR-2506", "issueStringList": ["Stop text extraction when the maxFieldLength limit is reached", "When indexing large documents the text extraction often takes quite a while and uses lots of memory even if only the first maxFieldLength (by default 10000) tokens are used.", "I'd like to add a maxExtractLength parameter that can be used to set the maximum number of characters to extract from a binary.", "The default value of this parameter could be something like ten times the maxFieldLength setting.", "I implemented such a maxExtractLength parameter in revision 915356."], "SplitGT": [" Returns the maximum number of characters to extract from binaries."], "issueString": "Stop text extraction when the maxFieldLength limit is reached\nWhen indexing large documents the text extraction often takes quite a while and uses lots of memory even if only the first maxFieldLength (by default 10000) tokens are used. I'd like to add a maxExtractLength parameter that can be used to set the maximum number of characters to extract from a binary. The default value of this parameter could be something like ten times the maxFieldLength setting.\nI implemented such a maxExtractLength parameter in revision 915356.\n"}
{"aId": 31, "code": "public void setSizeEstimate(boolean b) {\n        if (b) {\n            log.info(\"Size estimation is enabled\");\n        }\n        this.sizeEstimate = b;\n    }", "comment": " If enabled, NodeIterator.getSize may report a larger value than the actual result. This value may shrink when the query result encounters non-existing nodes or the session does not have access to a node. This might be a security problem.", "issueId": "JCR-3858", "issueStringList": ["NodeIterator.getSize(): compatibility with Jackrabbit 2.5", "In Jackrabbit 2.5 and older, the query result set (NodeIterator.getSize()) was an estimation that sometimes included nodes that are not visible for the current user.", "This is a possible security problem.", "The behavior was changed (and the security problem fixed) in JCR-3402.", "However, this is an incompatibility with Jackrabbit 2.5.", "I suggest to make this configurable in workspace.xml / repository.xml (or a system property, if that turns out to be too complicated).", "The default is the current (secure) behavior, with the option to use the old variant.", "Patch for review:", "{noformat}", "Index: src/main/java/org/apache/jackrabbit/core/query/lucene/QueryResultImpl.java", "===================================================================", "src/main/java/org/apache/jackrabbit/core/query/lucene/QueryResultImpl.java\t(revision 1641780)", "+++ src/main/java/org/apache/jackrabbit/core/query/lucene/QueryResultImpl.java\t(working copy)", "@@ -39,7 +39,7 @@", "Implements the <code>QueryResult</code> interface.", "public abstract class QueryResultImpl implements JackrabbitQueryResult {", "+", "The logger instance for this class", "@@ -119,6 +119,8 @@", "The maximum size of this result if limit >= 0", "private final long limit;", "+", "+    private final boolean sizeEstimate;", "Creates a new query result.", "The concrete sub class is responsible for", "@@ -146,6 +148,7 @@", "ColumnImpl[] columns, boolean documentOrder,", "long offset, long limit) throws RepositoryException {", "this.index = index;", "+        this.sizeEstimate = index.getSizeEstimate();", "this.sessionContext = sessionContext;", "this.queryImpl = queryImpl;", "this.spellSuggestion = spellSuggestion;", "@@ -258,10 +261,12 @@", "log.debug(\"getResults({}) limit={}\", size, limit);", "}", "// quick check", "// if numResults is set, all relevant results have been fetched", "if (numResults != -1) {", "return;", "+        if (!sizeEstimate) {", "+            // quick check", "+            // if numResults is set, all relevant results have been fetched", "+            if (numResults != -1) {", "+                return;", "+            }", "}", "long maxResultSize = size;", "@@ -291,7 +296,11 @@", "List<ScoreNode[]> offsetNodes = new ArrayList<ScoreNode[]>();", "if (resultNodes.isEmpty() && offset > 0) {", "collect result offset into dummy list", "collectScoreNodes(result, offsetNodes, offset);", "+                if (sizeEstimate) {", "+                    collectScoreNodes(result, new ArrayList<ScoreNode[]>(), offset);", "+                } else {", "+                    collectScoreNodes(result, offsetNodes, offset);", "+                }", "} else {", "int start = resultNodes.size() + invalid + (int) offset;", "result.skip(start);", "@@ -303,24 +312,29 @@", "log.debug(\"retrieved ScoreNodes in {} ms ({})\",", "System.currentTimeMillis() - time, r3 - r2);", "// update numResults if all results have been fetched", "// if resultNodes.getSize() is strictly smaller than maxResultSize, it means that all results have been fetched", "int resultSize = resultNodes.size();", "if (resultSize < maxResultSize) {", "if (resultNodes.isEmpty()) {", "// if there's no result nodes, the actual totalResults if smaller or equals than the offset", "totalResults = offsetNodes.size();", "numResults = 0;", "+            if (sizeEstimate) {", "+                // update numResults", "+                numResults = result.getSize();", "+            } else {", "+                // update numResults if all results have been fetched", "+                // if resultNodes.getSize() is strictly smaller than maxResultSize, it means that all results have been fetched", "+                int resultSize = resultNodes.size();", "+                if (resultSize < maxResultSize) {", "+                    if (resultNodes.isEmpty()) {", "+                        // if there's no result nodes, the actual totalResults if smaller or equals than the offset", "+                        totalResults = offsetNodes.size();", "+                        numResults = 0;", "+                    }", "+                    else {", "+                        totalResults = resultSize + (int) offset;", "+                        numResults = resultSize;", "+                    }", "}", "else {", "totalResults = resultSize + (int) offset;", "numResults = resultSize;", "+                else if (resultSize == limit) {", "+                    // if there's \"limit\" results, we can't know the total size (which may be greater), but the result size is the limit", "+                    numResults = (int) limit;", "}", "}", "else if (resultSize == limit) {", "// if there's \"limit\" results, we can't know the total size (which may be greater), but the result size is the limit", "numResults = (int) limit;", "}", "} catch (IOException e) {", "throw new RepositoryException(e);", "} finally {", "@@ -393,11 +407,23 @@", "will get get if you don't set any limit or offset.", "This method may return", "<code>-1</code> if the total size is unknown.", "<p>", "+     * If the \"sizeEstimate\" options is enabled:", "+     * Keep in mind that this number may get smaller if nodes are found in", "+     * the result set which the current session has no permission to access.", "+     * This might be a security problem.", "@return the total number of hits.", "public int getTotalSize() {", "return totalResults;", "+        if (sizeEstimate) {", "+            if (numResults == -1) {", "+                return -1;", "+            } else {", "+                return numResults - invalid;", "+            }", "+        } else {", "+            return totalResults;", "+        }", "}", "private final class LazyScoreNodeIteratorImpl implements ScoreNodeIterator {", "@@ -448,9 +474,26 @@", "{@inheritDoc}", "+         * <p/>", "+         * If the \"sizeEstimate\" options is enabled:", "+         * This value may shrink when the query result encounters non-existing", "+         * nodes or the session does not have access to a node.", "public long getSize() {", "return numResults;", "+            if (sizeEstimate) {", "+                int total = getTotalSize();", "+                if (total == -1) {", "+                    return -1;", "+                }", "+                long size = offset > total ?", "0 : total - offset;", "+                if (limit >= 0 && size > limit) {", "+                    return limit;", "+                } else {", "+                    return size;", "+                }", "+            } else {", "+                return numResults;", "+            }", "}", "@@ -504,9 +547,16 @@", "while (next == null) {", "if (nextPos >= resultNodes.size()) {", "quick check if there are more results at all", "// if numResults is set, all relevant results have been fetched", "if (numResults != -1) {", "break;", "+                    if (sizeEstimate) {", "+                        // this check is only possible if we have numResults", "+                        if (numResults != -1 && (nextPos + invalid) >= numResults) {", "+                            break;", "+                        }", "+                    } else {", "+                        // if numResults is set, all relevant results have been fetched", "+                        if (numResults != -1) {", "+                            break;", "+                        }", "}", "fetch more results", "Index: src/main/java/org/apache/jackrabbit/core/query/lucene/SearchIndex.java", "===================================================================", "src/main/java/org/apache/jackrabbit/core/query/lucene/SearchIndex.java\t(revision 1641780)", "+++ src/main/java/org/apache/jackrabbit/core/query/lucene/SearchIndex.java\t(working copy)", "@@ -386,6 +386,14 @@", "Default value is: <code>false</code>.", "private boolean supportHighlighting = false;", "+", "+    /**", "+     * If enabled, NodeIterator.getSize() may report a larger value than the", "+     * actual result.", "This value may shrink when the query result encounters", "+     * non-existing nodes or the session does not have access to a node.", "This", "+     * might be a security problem.", "+     */", "+    private boolean sizeEstimate = false;", "The excerpt provider class.", "Implements {@link ExcerptProvider}.", "@@ -2178,6 +2186,27 @@", "public long getExtractorTimeout() {", "return extractorTimeout;", "}", "+", "+    /**", "+     * If enabled, NodeIterator.getSize() may report a larger value than the", "+     * actual result.", "This value may shrink when the query result encounters", "+     * non-existing nodes or the session does not have access to a node.", "This", "+     * might be a security problem.", "+     *", "+     * @param b <code>true</code> to enable", "+     */", "+    public void setSizeEstimate(boolean b) {", "+        this.sizeEstimate = b;", "+    }", "+", "+    /**", "+     * Get the size estimate setting.", "+     *", "+     * @return the setting", "+     */", "+    public boolean getSizeEstimate() {", "+        return sizeEstimate;", "+    }", "If set to <code>true</code> additional information is stored in the index", "{noformat}", "Patch looks good (gather both old and new behaviour), but do we want to ensure backward compatibility even in case of a possible security problem ?", "If so, that's ok.", "I think by default it should be as secure as possible.", "And with the patch, this is the case.", "We should provide backward compatibility, but the user would have to explicitly enable this, and it needs to be clear that enabling it is potentially a (very small) security problem.", "Revision 1667317 (trunk)", "Revision 1667318 (2.6 branch)", "To enable, the property \"sizeEstimate\" needs to be set to \"true\" in all \"SearchIndex\" configurations, in all \"repository.xml\" and \"workspace.xml\" files.", "Example (\"...\" is a placeholder for existing settings).", "{noformat}", "<SearchIndex class=\"com.day.crx.query.lucene.LuceneHandler\">", "....", "<param name=\"sizeEstimate\" value=\"true\"/>", "</SearchIndex>", "{noformat}", "In addition to the patch above, I added an info level log message \"Size estimation is enabled\".", "This is to check that the patch is installed and the feature is really enabled."], "SplitGT": [" If enabled, NodeIterator.getSize may report a larger value than the actual result.", "This value may shrink when the query result encounters non-existing nodes or the session does not have access to a node.", "This might be a security problem."], "issueString": "NodeIterator.getSize(): compatibility with Jackrabbit 2.5\nIn Jackrabbit 2.5 and older, the query result set (NodeIterator.getSize()) was an estimation that sometimes included nodes that are not visible for the current user.\n\nThis is a possible security problem. The behavior was changed (and the security problem fixed) in JCR-3402. However, this is an incompatibility with Jackrabbit 2.5.\n\nI suggest to make this configurable in workspace.xml / repository.xml (or a system property, if that turns out to be too complicated). The default is the current (secure) behavior, with the option to use the old variant.\n\nPatch for review:\n\n{noformat}\nIndex: src/main/java/org/apache/jackrabbit/core/query/lucene/QueryResultImpl.java\n===================================================================\n--- src/main/java/org/apache/jackrabbit/core/query/lucene/QueryResultImpl.java\t(revision 1641780)\n+++ src/main/java/org/apache/jackrabbit/core/query/lucene/QueryResultImpl.java\t(working copy)\n@@ -39,7 +39,7 @@\n  * Implements the <code>QueryResult</code> interface.\n  */\n public abstract class QueryResultImpl implements JackrabbitQueryResult {\n-\n+    \n     /**\n      * The logger instance for this class\n      */\n@@ -119,6 +119,8 @@\n      * The maximum size of this result if limit >= 0\n      */\n     private final long limit;\n+    \n+    private final boolean sizeEstimate;\n \n     /**\n      * Creates a new query result. The concrete sub class is responsible for\n@@ -146,6 +148,7 @@\n             ColumnImpl[] columns, boolean documentOrder,\n             long offset, long limit) throws RepositoryException {\n         this.index = index;\n+        this.sizeEstimate = index.getSizeEstimate();\n         this.sessionContext = sessionContext;\n         this.queryImpl = queryImpl;\n         this.spellSuggestion = spellSuggestion;\n@@ -258,10 +261,12 @@\n             log.debug(\"getResults({}) limit={}\", size, limit);\n         }\n         \n-        // quick check\n-        // if numResults is set, all relevant results have been fetched\n-        if (numResults != -1) {\n-            return;\n+        if (!sizeEstimate) {\n+            // quick check\n+            // if numResults is set, all relevant results have been fetched\n+            if (numResults != -1) {\n+                return;\n+            }\n         }\n \n         long maxResultSize = size;\n@@ -291,7 +296,11 @@\n             List<ScoreNode[]> offsetNodes = new ArrayList<ScoreNode[]>();\n             if (resultNodes.isEmpty() && offset > 0) {\n                 // collect result offset into dummy list\n-                collectScoreNodes(result, offsetNodes, offset);\n+                if (sizeEstimate) {\n+                    collectScoreNodes(result, new ArrayList<ScoreNode[]>(), offset);                    \n+                } else {\n+                    collectScoreNodes(result, offsetNodes, offset);\n+                }\n             } else {\n                 int start = resultNodes.size() + invalid + (int) offset;\n                 result.skip(start);\n@@ -303,24 +312,29 @@\n             log.debug(\"retrieved ScoreNodes in {} ms ({})\",\n                     System.currentTimeMillis() - time, r3 - r2);\n \n-            // update numResults if all results have been fetched \n-            // if resultNodes.getSize() is strictly smaller than maxResultSize, it means that all results have been fetched\n-            int resultSize = resultNodes.size();\n-            if (resultSize < maxResultSize) {\n-                if (resultNodes.isEmpty()) {\n-                    // if there's no result nodes, the actual totalResults if smaller or equals than the offset\n-                    totalResults = offsetNodes.size();\n-                    numResults = 0;\n+            if (sizeEstimate) {\n+                // update numResults\n+                numResults = result.getSize();                \n+            } else {\n+                // update numResults if all results have been fetched \n+                // if resultNodes.getSize() is strictly smaller than maxResultSize, it means that all results have been fetched\n+                int resultSize = resultNodes.size();\n+                if (resultSize < maxResultSize) {\n+                    if (resultNodes.isEmpty()) {\n+                        // if there's no result nodes, the actual totalResults if smaller or equals than the offset\n+                        totalResults = offsetNodes.size();\n+                        numResults = 0;\n+                    }\n+                    else {\n+                        totalResults = resultSize + (int) offset;\n+                        numResults = resultSize;\n+                    }\n                 }\n-                else {\n-                    totalResults = resultSize + (int) offset;\n-                    numResults = resultSize;\n+                else if (resultSize == limit) {\n+                    // if there's \"limit\" results, we can't know the total size (which may be greater), but the result size is the limit\n+                    numResults = (int) limit;\n                 }\n             }\n-            else if (resultSize == limit) {\n-                // if there's \"limit\" results, we can't know the total size (which may be greater), but the result size is the limit\n-                numResults = (int) limit;\n-            }\n         } catch (IOException e) {\n             throw new RepositoryException(e);\n         } finally {\n@@ -393,11 +407,23 @@\n      * will get get if you don't set any limit or offset. This method may return\n      * <code>-1</code> if the total size is unknown.\n      * <p>\n+     * If the \"sizeEstimate\" options is enabled:\n+     * Keep in mind that this number may get smaller if nodes are found in\n+     * the result set which the current session has no permission to access.\n+     * This might be a security problem.\n      *\n      * @return the total number of hits.\n      */\n     public int getTotalSize() {\n-        return totalResults;\n+        if (sizeEstimate) {\n+            if (numResults == -1) {\n+                return -1;\n+            } else {\n+                return numResults - invalid;\n+            }\n+        } else {\n+            return totalResults;\n+        }\n     }\n \n     private final class LazyScoreNodeIteratorImpl implements ScoreNodeIterator {\n@@ -448,9 +474,26 @@\n \n         /**\n          * {@inheritDoc}\n+         * <p/>\n+         * If the \"sizeEstimate\" options is enabled:\n+         * This value may shrink when the query result encounters non-existing\n+         * nodes or the session does not have access to a node.\n          */\n         public long getSize() {\n-            return numResults;\n+            if (sizeEstimate) {\n+                int total = getTotalSize();\n+                if (total == -1) {\n+                    return -1;\n+                }\n+                long size = offset > total ? 0 : total - offset;\n+                if (limit >= 0 && size > limit) {\n+                    return limit;\n+                } else {\n+                    return size;\n+                }                \n+            } else {\n+                return numResults;\n+            }\n         }\n \n         /**\n@@ -504,9 +547,16 @@\n             while (next == null) {\n                 if (nextPos >= resultNodes.size()) {\n                     // quick check if there are more results at all\n-                    // if numResults is set, all relevant results have been fetched\n-                    if (numResults != -1) {\n-                        break;\n+                    if (sizeEstimate) {\n+                        // this check is only possible if we have numResults\n+                        if (numResults != -1 && (nextPos + invalid) >= numResults) {\n+                            break;\n+                        }\n+                    } else {\n+                        // if numResults is set, all relevant results have been fetched\n+                        if (numResults != -1) {\n+                            break;\n+                        }\n                     }\n \n                     // fetch more results\nIndex: src/main/java/org/apache/jackrabbit/core/query/lucene/SearchIndex.java\n===================================================================\n--- src/main/java/org/apache/jackrabbit/core/query/lucene/SearchIndex.java\t(revision 1641780)\n+++ src/main/java/org/apache/jackrabbit/core/query/lucene/SearchIndex.java\t(working copy)\n@@ -386,6 +386,14 @@\n      * Default value is: <code>false</code>.\n      */\n     private boolean supportHighlighting = false;\n+    \n+    /**\n+     * If enabled, NodeIterator.getSize() may report a larger value than the\n+     * actual result. This value may shrink when the query result encounters\n+     * non-existing nodes or the session does not have access to a node. This\n+     * might be a security problem.\n+     */\n+    private boolean sizeEstimate = false;\n \n     /**\n      * The excerpt provider class. Implements {@link ExcerptProvider}.\n@@ -2178,6 +2186,27 @@\n     public long getExtractorTimeout() {\n         return extractorTimeout;\n     }\n+    \n+    /**\n+     * If enabled, NodeIterator.getSize() may report a larger value than the\n+     * actual result. This value may shrink when the query result encounters\n+     * non-existing nodes or the session does not have access to a node. This\n+     * might be a security problem.\n+     * \n+     * @param b <code>true</code> to enable\n+     */\n+    public void setSizeEstimate(boolean b) {\n+        this.sizeEstimate = b;\n+    }\n+    \n+    /**\n+     * Get the size estimate setting.\n+     * \n+     * @return the setting\n+     */\n+    public boolean getSizeEstimate() {\n+        return sizeEstimate;\n+    }\n \n     /**\n      * If set to <code>true</code> additional information is stored in the index\n{noformat}\nPatch looks good (gather both old and new behaviour), but do we want to ensure backward compatibility even in case of a possible security problem ?\nIf so, that's ok.\nI think by default it should be as secure as possible. And with the patch, this is the case.\n\nWe should provide backward compatibility, but the user would have to explicitly enable this, and it needs to be clear that enabling it is potentially a (very small) security problem.\nRevision 1667317 (trunk)\nRevision 1667318 (2.6 branch)\nTo enable, the property \"sizeEstimate\" needs to be set to \"true\" in all \"SearchIndex\" configurations, in all \"repository.xml\" and \"workspace.xml\" files. Example (\"...\" is a placeholder for existing settings).\n\n{noformat}\n<SearchIndex class=\"com.day.crx.query.lucene.LuceneHandler\">\n    ....\n    <param name=\"sizeEstimate\" value=\"true\"/>\n</SearchIndex>\n{noformat}\n\nIn addition to the patch above, I added an info level log message \"Size estimation is enabled\". This is to check that the patch is installed and the feature is really enabled.\n"}
{"aId": 32, "code": "public NodeType[] registerNodeTypes(InputSource in)\n            throws SAXException, RepositoryException {\n        try {\n            NodeTypeDef[] defs = NodeTypeReader.read(in.getByteStream());\n            return registerNodeTypes(Arrays.asList(defs));\n        } catch (InvalidNodeTypeDefException e) {\n            throw new RepositoryException(\"Invalid node type definition\", e);\n        } catch (IOException e) {\n            throw new SAXException(\"Error reading node type stream\", e);\n        }\n    }", "comment": " Registers the node types defined in the given XML stream.", "issueId": "JCR-309", "issueStringList": ["Extract the public API interfaces from o.a.j.core to o.a.j.api", "To better document and track the public JCR extensions and component API provided by Jackrabbit and to allow more room for refactoring within the Jackrabbit core, we shoud move (or create) the supported API interfaces to a new org.apache.jackrabbit.api package.", "At least the following interfaces should be moved along with any supporting implementation-independent classes:", "PersistenceManager", "FileSystem", "AccessManager", "QueryHandler", "TextFilter", "Possible dependencies to implementation-specific classes should preferably be abstracted using extra interfaces.", "Also the workspace and node type administration methods should be published as Jackrabbit-specific extensions to the JCR API interfaces.", "well, some of those groups are rather interfaces that provide a backend service, and are not usefull for the 'client'.", "so i would devide:", "Client Interface:", "NodeType stuff", "Service Provider Interface", "PersistenceManager", "FileSystem", "AccessManager", "QueryHandler", "TextFilter", "> well, some of those groups are rather interfaces that provide a backend service, and are not usefull for the 'client'", "Agreed, that's what I was trying to convey with \"component API\".", "You are right that SPI is a better term for those interfaces.", "Perhaps we should create o.a.j.api for the JCR API extensions and o.a.j.spi for the component interfaces.", "Attached a patch for creating public interfaces for RepositoryImpl.shutdown() and WorkspaceImpl.createWorkspace(String).", "Does this look OK?", "If so, I'll go ahead and commit it.", "I also investigated the options for doing the same to node type registration.", "Exposing the current NodeTypeManagerImpl.getNodeTypeRegistry().registerNodeTypes(Collection) method will require also the *Def interfaces (optionally also the *DefImpl classes) to be exposed.", "This will also bring a dependency to the QName class.", "Is it OK to expose so much (essentially promising that they will not change much before Jackrabbit 2.0) or should we create an alternative like NodeTypeManagerImpl.registerNodeTypes(InputStream)?", "> Attached a patch for creating public interfaces for RepositoryImpl.shutdown()", "> and WorkspaceImpl.createWorkspace(String).", "Does this look OK?", "If so, I'll go", "> ahead and commit it.", "+1", "maybe we should add an optional Properties argument to the createWorkspace signatur.", "> ... or should we create an alternative like NodeTypeManagerImpl.registerNodeTypes(InputStream)?", "i prefer NodeTypeManagerImpl.registerNodeTypes(InputStream)", "if find NodeTypeManagerImpl.registerNodeTypes(InputStream) very useless.", "since clients would need to fake XML in order to create the node types.", "i suggest to elaborate NodeType stuff for 2.0 and then expose this api.", "While I tend to agree with Tobias that it would probably be better to have the item definition classes available for the casual use, it would probably also be usefull to be able to just register node types from pre-canned xml files.", "Imagine a repository application which requires a set of node types.", "The definitions would be distributed in the form of XML - or better yet the new CND - format and could just be registered by handing a stream to the respective file.", "IMHO, the InputStream solution is not the best of all solutions, but it is still far better than nothing.", "Stefan:", "> maybe we should add an optional Properties argument to the createWorkspace signatur.", "What should it do?", "The current WorkspaceImpl.createWorkspace signature doesn't have it so we'd need to specify how the given properties will be interpreted and implement that interpretation.", "We can add JackrabbitWorkspace.createWorkspace(String,Properties) without breaking backwards compatibility also later during the 1.x cycle.", "I suggest that we do so only when the given properties are actually used.", "Felix:", "> IMHO, the InputStream solution is not the best of all solutions, but it is still far better than nothing.", "Agreed.", "We must have at least one officially supported node type registration mechanism in 1.0.", "The InputStream solution covers at least the basic use case without exposing too much of the Jackrabbit internals.", "A more integrated tool can always use the internal Jackrabbit interfaces directly to get more control over the registration process, but there would be no guarantees of backwards compatibility for such clients.", "ok. lets add the register nodetype.", "but i would prefer an 'org.xml.sax.InputSource' instead of the input stream.", "and maybe an additional content type:", "public NodeType[] NodeTypeManagerImpl.registerNodeTypes(InputSource in, String contentType);", "contentType is either: text/xml or text/cnd", "the advantage of the inputsource is: it has a systemId that can be used to resolve entities (eg: relatvie DVDs), and also for better error reporting.", "InputSource makes little sense to non-XML data like the CND.", "How about the following?", "NodeType[] registerNodeTypes(InputSource in) throws ...;", "NodeType[] registerNodeTypes(InputStream in, String contentType) throws ...;", "Constants for the supported content types", "String XML = \"text/xml\";", "String CND = \"text/x-jcr-cnd\";", "(The implementation should also support application/xml as the XML content type.)", "Added the o.a.j.api.JackrabbitNodeTypeManager extension interface in revision 378211.", "The new API methods are implemented quite simplistically using the existing NodeTypeReader and NodeTypeRegistry methods.", "Currently only text/xml (and application/xml) are supported, we can add support for CND when the CND parser is promoted from contrib.", "Together with previous commits this should cover the major JCR extensions in Jackrabbit, so I'm resolving this issue as Fixed.", "Please file a new issue if other public extensions are needed."], "SplitGT": [" Registers the node types defined in the given XML stream."], "issueString": "Extract the public API interfaces from o.a.j.core to o.a.j.api\nTo better document and track the public JCR extensions and component API provided by Jackrabbit and to allow more room for refactoring within the Jackrabbit core, we shoud move (or create) the supported API interfaces to a new org.apache.jackrabbit.api package.\n\nAt least the following interfaces should be moved along with any supporting implementation-independent classes:\n\n    * PersistenceManager\n    * FileSystem\n    * AccessManager\n    * QueryHandler\n    * TextFilter\n\nPossible dependencies to implementation-specific classes should preferably be abstracted using extra interfaces.\n\nAlso the workspace and node type administration methods should be published as Jackrabbit-specific extensions to the JCR API interfaces.\n\nwell, some of those groups are rather interfaces that provide a backend service, and are not usefull for the 'client'. so i would devide:\n\nClient Interface:\n- NodeType stuff\n\nService Provider Interface\n- PersistenceManager \n- FileSystem \n- AccessManager \n- QueryHandler \n- TextFilter \n\n> well, some of those groups are rather interfaces that provide a backend service, and are not usefull for the 'client'\n\nAgreed, that's what I was trying to convey with \"component API\". You are right that SPI is a better term for those interfaces.\n\nPerhaps we should create o.a.j.api for the JCR API extensions and o.a.j.spi for the component interfaces.\nAttached a patch for creating public interfaces for RepositoryImpl.shutdown() and WorkspaceImpl.createWorkspace(String). Does this look OK? If so, I'll go ahead and commit it.\n\nI also investigated the options for doing the same to node type registration. Exposing the current NodeTypeManagerImpl.getNodeTypeRegistry().registerNodeTypes(Collection) method will require also the *Def interfaces (optionally also the *DefImpl classes) to be exposed. This will also bring a dependency to the QName class. Is it OK to expose so much (essentially promising that they will not change much before Jackrabbit 2.0) or should we create an alternative like NodeTypeManagerImpl.registerNodeTypes(InputStream)?\n> Attached a patch for creating public interfaces for RepositoryImpl.shutdown() \n> and WorkspaceImpl.createWorkspace(String). Does this look OK? If so, I'll go \n> ahead and commit it. \n\n+1\n\nmaybe we should add an optional Properties argument to the createWorkspace signatur.\n\n> ... or should we create an alternative like NodeTypeManagerImpl.registerNodeTypes(InputStream)?\n\ni prefer NodeTypeManagerImpl.registerNodeTypes(InputStream)\nif find NodeTypeManagerImpl.registerNodeTypes(InputStream) very useless. since clients would need to fake XML in order to create the node types.\ni suggest to elaborate NodeType stuff for 2.0 and then expose this api.\nWhile I tend to agree with Tobias that it would probably be better to have the item definition classes available for the casual use, it would probably also be usefull to be able to just register node types from pre-canned xml files.\n\nImagine a repository application which requires a set of node types. The definitions would be distributed in the form of XML - or better yet the new CND - format and could just be registered by handing a stream to the respective file.\n\nIMHO, the InputStream solution is not the best of all solutions, but it is still far better than nothing.\nStefan:\n> maybe we should add an optional Properties argument to the createWorkspace signatur. \n\nWhat should it do? The current WorkspaceImpl.createWorkspace signature doesn't have it so we'd need to specify how the given properties will be interpreted and implement that interpretation.\n\nWe can add JackrabbitWorkspace.createWorkspace(String,Properties) without breaking backwards compatibility also later during the 1.x cycle. I suggest that we do so only when the given properties are actually used.\n\nFelix:\n> IMHO, the InputStream solution is not the best of all solutions, but it is still far better than nothing.\n\nAgreed. We must have at least one officially supported node type registration mechanism in 1.0. The InputStream solution covers at least the basic use case without exposing too much of the Jackrabbit internals.\n\nA more integrated tool can always use the internal Jackrabbit interfaces directly to get more control over the registration process, but there would be no guarantees of backwards compatibility for such clients.\nok. lets add the register nodetype. but i would prefer an 'org.xml.sax.InputSource' instead of the input stream. and maybe an additional content type:\n\npublic NodeType[] NodeTypeManagerImpl.registerNodeTypes(InputSource in, String contentType);\n\ncontentType is either: text/xml or text/cnd\n\nthe advantage of the inputsource is: it has a systemId that can be used to resolve entities (eg: relatvie DVDs), and also for better error reporting.\n\n\nInputSource makes little sense to non-XML data like the CND. How about the following?\n\n    /** Registers node types from the given node type XML stream. */\n    NodeType[] registerNodeTypes(InputSource in) throws ...;\n\n    /** Registers node types from the given input stream of the given type. */\n    NodeType[] registerNodeTypes(InputStream in, String contentType) throws ...;\n\n    // Constants for the supported content types\n    String XML = \"text/xml\";\n    String CND = \"text/x-jcr-cnd\";\n\n(The implementation should also support application/xml as the XML content type.)\nAdded the o.a.j.api.JackrabbitNodeTypeManager extension interface in revision 378211. The new API methods are implemented quite simplistically using the existing NodeTypeReader and NodeTypeRegistry methods. Currently only text/xml (and application/xml) are supported, we can add support for CND when the CND parser is promoted from contrib.\n\nTogether with previous commits this should cover the major JCR extensions in Jackrabbit, so I'm resolving this issue as Fixed. Please file a new issue if other public extensions are needed.\n"}
{"aId": 33, "code": "public static RepositoryConfig install(File dir)\n            throws IOException, ConfigurationException {\n        return install(new File(dir, REPOSITORY_XML), dir);\n    }", "comment": " Returns the configuration of a repository in a given repository directory. The repository configuration is read from a \"repository.xml\" file inside the repository directory. If the repository configuration file does not exist, then it is created using the default Jackrabbit configuration settings.", "issueId": "JCR-2119", "issueStringList": ["Method to create default RepositoryConfig from just the repository directory", "It would be useful to have a static method like RepositoryConfig.create(File) that would take the repository directory and expect to find the repository configuration in a \"repository.xml\" file inside that directory.", "If the directory does not exist, it would be created.", "And if the repository configuration file does not exist, then it would be created from the default configuration included in Jackrabbit.", "Added the following methods in revision 776310:", "RepositoryConfig.install(File dir);", "RepostiroyConfig.install(File xml, File dir);", "RepositoryConfig.create(File dir);", "RepositoryConfig.create(File xml, File dir);", "The install() methods will automatically create the repository directory and configuration file if they do not already exist.", "The create() methods will fail with an exception in the same situation."], "SplitGT": [" Returns the configuration of a repository in a given repository directory.", "The repository configuration is read from a \"repository.xml\" file inside the repository directory.", "If the repository configuration file does not exist, then it is created using the default Jackrabbit configuration settings."], "issueString": "Method to create default RepositoryConfig from just the repository directory\nIt would be useful to have a static method like RepositoryConfig.create(File) that would take the repository directory and expect to find the repository configuration in a \"repository.xml\" file inside that directory.\n\nIf the directory does not exist, it would be created. And if the repository configuration file does not exist, then it would be created from the default configuration included in Jackrabbit.\nAdded the following methods in revision 776310:\n\n   RepositoryConfig.install(File dir);\n   RepostiroyConfig.install(File xml, File dir);\n   RepositoryConfig.create(File dir);\n   RepositoryConfig.create(File xml, File dir);\n\nThe install() methods will automatically create the repository directory and configuration file if they do not already exist. The create() methods will fail with an exception in the same situation.\n"}
{"aId": 34, "code": "private AtomicTypeConverter getAtomicTypeConverter(CollectionDescriptor collectionDescriptor) {\n        String elementClassName = collectionDescriptor.getElementClassName();\n        Class elementClass = ReflectionUtils.forName(elementClassName);\n        AtomicTypeConverter atc = (AtomicTypeConverter) atomicTypeConverters.get(elementClass);\n        if (atc != null) {\n            return atc;\n        }\n        \n        throw new PersistenceException(\n            \"Cannot get AtomicTypeConverter for element class \"\n                + elementClassName + \" of class \"\n                + collectionDescriptor.getClassDescriptor().getClassName());\n    }", "comment": " If no such converter can be found a PersistenceException is thrown.", "issueId": "JCR-866", "issueStringList": ["ResidualProperties Converter uses wrong AtomicType Converter on update", "When writing back data, the ResidualPropertiesCollectionConverterImpl.internalSetProperties method looks at the type of the Java object", "to find the atomic type converter instead of getting the converter according to the collection descriptor.", "This may lead to NullPointerExceptions in case the concrete type is an extension (or implementation) of the declared type.", "I am currently working on a patch to attache to this bug.", "And here is the patch.", "Note that the ResidualProperties converter will now throw a PersistenceException on read or write if no atomic type converter can be found for the element class name.", "Patch applied.", "Sorry for the delay.", "Felix, can you check if it is ok ?", "thanks"], "SplitGT": [" If no such converter can be found a PersistenceException is thrown."], "issueString": "ResidualProperties Converter uses wrong AtomicType Converter on update\nWhen writing back data, the ResidualPropertiesCollectionConverterImpl.internalSetProperties method looks at the type of the Java object\nto find the atomic type converter instead of getting the converter according to the collection descriptor.\n\nThis may lead to NullPointerExceptions in case the concrete type is an extension (or implementation) of the declared type.\n\nI am currently working on a patch to attache to this bug.\nAnd here is the patch.\n\nNote that the ResidualProperties converter will now throw a PersistenceException on read or write if no atomic type converter can be found for the element class name.\nPatch applied. Sorry for the delay. Felix, can you check if it is ok ? thanks\n"}
{"aId": 36, "code": "public ManagedConnection createManagedConnection(Subject subject, ConnectionRequestInfo cri)\n            throws ResourceException {\n\n        if (cri == null) {\n            return new AnonymousConnection();\n        }\n        return createManagedConnection((JCAConnectionRequestInfo) cri);\n    }", "comment": " WebSphere 5.1.1 will try to recover an XA resource on startup, regardless whether it was committed or rolled back.", "issueId": "JCR-743", "issueStringList": ["XA Transaction Recovery", "If i add a node to the repository i get a XAException because i run into a Timeout ...", "I see the Warn Message: Transaction rolled back because timeout expired.", "The default Timeout is set to 5 sec and i dont know how to set it to a higher value", "The Problem is if i restart my server websphere has a RecoveryManager and he try to recover this Transaction", "and then i get a NullpointerException in JCAManagedConnectionFactory.", "createManagedConnection beacuse the given", "ConnectionRequestInfo is null.", "So i dont know why the RecoveryManager tries to recover the Transaction ?", "The only solution for me is to delete the Tran-Log Files wich keep Websphere to recvoer", "XA Trasnactions.", "I have tested more with this behaviour.", "For more information my environment in detail:", "Websphere 5.1.1 and Jackrabbit as J2C Resource Adapter", "My Workspace configuration:", "<PersistenceManager class=\"org.apache.jackrabbit.core.state.db.JNDIDatabasePersistenceManager\">", "<param name=\"dataSourceLocation\" value=\"jdbc/JCR\"/>", "<param name=\"schema\" value=\"oracle\"/>", "<param name=\"schemaObjectPrefix\" value=\"${wsp.name}_\"/>", "<param name=\"externalBLOBs\" value=\"false\"/>", "</PersistenceManager>", "The DataSource jdbc/JCR is a oracle.jdbc.pool.OracleConnectionPoolDataSource.", "I have also tested a oracle.jdbc.xa.client.OracleXADataSource", "but then i get a Exception on commit @see JCR-744", "I have a SessionBean where i make some calls to to Jackrabbit within a Transaction.", "I made a clean start.", "(starting my Server and Jackrabbit to a a empty repository).", "If i add a node to the repository within transaction there are no problems.", "Now i stop the server and restart it and i get  always the Nullpointer Exception.", "First i thought that is only if a make a Rollback but that is not so.", "I try to find out why Websphere try to recover the transaction ...", "WebSphere 5.1.1 tries to recover the connection's associated XAResource on startup, regardless whether it was committed or rolled back.", "In order to be interoperable, an anonymous, recoverable-only connection is returned, when this situation is detected.", "Fixed in revision 510465."], "SplitGT": [" WebSphere 5.1.1 will try to recover an XA resource on startup, regardless whether it was committed or rolled back."], "issueString": "XA Transaction Recovery\nIf i add a node to the repository i get a XAException because i run into a Timeout ... \nI see the Warn Message: Transaction rolled back because timeout expired.\nThe default Timeout is set to 5 sec and i dont know how to set it to a higher value\nThe Problem is if i restart my server websphere has a RecoveryManager and he try to recover this Transaction\nand then i get a NullpointerException in JCAManagedConnectionFactory. createManagedConnection beacuse the given \nConnectionRequestInfo is null.\nSo i dont know why the RecoveryManager tries to recover the Transaction ? The only solution for me is to delete the Tran-Log Files wich keep Websphere to recvoer\nXA Trasnactions.\n\nI have tested more with this behaviour.\nFor more information my environment in detail:\nWebsphere 5.1.1 and Jackrabbit as J2C Resource Adapter\nMy Workspace configuration:\n    <PersistenceManager class=\"org.apache.jackrabbit.core.state.db.JNDIDatabasePersistenceManager\">\n       <param name=\"dataSourceLocation\" value=\"jdbc/JCR\"/>\n       <param name=\"schema\" value=\"oracle\"/>\n       <param name=\"schemaObjectPrefix\" value=\"${wsp.name}_\"/>\n       <param name=\"externalBLOBs\" value=\"false\"/>\n    </PersistenceManager>\nThe DataSource jdbc/JCR is a oracle.jdbc.pool.OracleConnectionPoolDataSource. I have also tested a oracle.jdbc.xa.client.OracleXADataSource\nbut then i get a Exception on commit @see JCR-744\nI have a SessionBean where i make some calls to to Jackrabbit within a Transaction.\n\nI made a clean start. (starting my Server and Jackrabbit to a a empty repository). \nIf i add a node to the repository within transaction there are no problems. \nNow i stop the server and restart it and i get  always the Nullpointer Exception. First i thought that is only if a make a Rollback but that is not so.\nI try to find out why Websphere try to recover the transaction ...\n\nWebSphere 5.1.1 tries to recover the connection's associated XAResource on startup, regardless whether it was committed or rolled back. In order to be interoperable, an anonymous, recoverable-only connection is returned, when this situation is detected.\n\nFixed in revision 510465.\n"}
{"aId": 39, "code": "protected boolean isPreAuthenticated(final Credentials creds) {\n        final String preAuthAttrName = getPreAuthAttributeName();\n        return preAuthAttrName != null\n            && (creds instanceof SimpleCredentials)\n            && ((SimpleCredentials) creds).getAttribute(preAuthAttrName) != null;\n    }", "comment": " Extensions of this class may overwrite this method to apply more or different checks to the credentials.", "issueId": "JCR-2355", "issueStringList": ["Support easy pre-authenticated login", "Some applications authenticate users themselves and just need to access the repository on behalf of these pre-authenticated users.", "Examples of such pre-authentications include SSO solutions or web applications using a web-based authentication protocol not easily implementable in a JAAS LoginModule, for example OpenID or similar.", "In such situations a password may not be provided in SimpleCredentials and thus regular login with user name and password is not possible.", "Therefore I propose the enhancement of the AbstractLoginModule to allow for setting a specific attribute in the SimpleCredentials attribute map.", "If this attribute is set, authentication and login succeeds and a session for the user named in the SimpleCredentials is created.", "As a starter we might just check for the presence of the attribute.", "Patch extending the AbstractLoginModule with support for pre-authentication.", "This patch adds the following:", "Support for a configuration parameter declaring a SimpleCredentials attribute for pre-authentication", "Add an isPreAuthenticated(Credentials) method used by the login() method", "The isPreAuthenticated method is protected and can be overwritten by AbstractLoginModule implementations to either switch pre authentication off completely or to apply different and more elaborate checks on the credentials.", "After having received the ok from Angela, I commit this patch in Rev.", "825125.", "+0 This approach seems a bit hacky to me (a separate SingleSignOnCredentials class would feel cleaner, or perhaps an out-of-band approach often used by JAAS implementations), but it's probably the most straightforward and easy to implement solution to the described use case."], "SplitGT": [" Extensions of this class may overwrite this method to apply more or different checks to the credentials."], "issueString": "Support easy pre-authenticated login\nSome applications authenticate users themselves and just need to access the repository on behalf of these pre-authenticated users.\n\nExamples of such pre-authentications include SSO solutions or web applications using a web-based authentication protocol not easily implementable in a JAAS LoginModule, for example OpenID or similar.\n\nIn such situations a password may not be provided in SimpleCredentials and thus regular login with user name and password is not possible.\n\nTherefore I propose the enhancement of the AbstractLoginModule to allow for setting a specific attribute in the SimpleCredentials attribute map. If this attribute is set, authentication and login succeeds and a session for the user named in the SimpleCredentials is created.\n\nAs a starter we might just check for the presence of the attribute.\nPatch extending the AbstractLoginModule with support for pre-authentication.\n\nThis patch adds the following:\n\n  * Support for a configuration parameter declaring a SimpleCredentials attribute for pre-authentication\n  * Add an isPreAuthenticated(Credentials) method used by the login() method\n\nThe isPreAuthenticated method is protected and can be overwritten by AbstractLoginModule implementations to either switch pre authentication off completely or to apply different and more elaborate checks on the credentials.\nAfter having received the ok from Angela, I commit this patch in Rev. 825125.\n+0 This approach seems a bit hacky to me (a separate SingleSignOnCredentials class would feel cleaner, or perhaps an out-of-band approach often used by JAAS implementations), but it's probably the most straightforward and easy to implement solution to the described use case.\n"}
{"aId": 42, "code": "private PropertyState getPropertyState() throws RepositoryException {\n        // JCR-1272: Need to get the state reference now so it\n        // doesn't get invalidated after the sanity check\n        ItemState state = getItemState();\n        sanityCheck();\n        return (PropertyState) state;\n    }", "comment": " and returns the underlying property state if all is OK.", "issueId": "JCR-1272", "issueStringList": ["Property.getValue() throws RepositoryException with internal error", "Running ConcurrentReadWriteTest (NUM_NODES=5, NUM_THREADS=3, RUN_NUM_SECONDS=120) resulted in a RepositoryException calling Property.getValue():", "javax.jcr.RepositoryException: Internal error while retrieving value of b3fc1ea8-3364-4236-bcc7-dea0baf90640/{}test: null: null", "Debugging shows that it is a NullPointerException:", "java.lang.NullPointerException", "at org.apache.jackrabbit.core.PropertyImpl.getValue(PropertyImpl.java:481)", "at org.apache.jackrabbit.core.ConcurrentReadWriteTest$1$1.execute(ConcurrentReadWriteTest.java:68)", "at org.apache.jackrabbit.core.AbstractConcurrencyTest$Executor.run(AbstractConcurrencyTest.java:110)", "at java.lang.Thread.run(Thread.java:619)", "It's probably the state which has been discarded after the sanityCheck().", "Moved getItemState() to the top of the method.", "This ensures that the state reference is still valid even if the property is discarded after the sanityCheck().", "What about all the other value getters like getString()?", "I guess we should make them just call getValue() instead of trying to optimize things.", "In fact there are tons of unguarded code that accesses the state variable.", "I'll come up with a patch for fixing them all.", "You are right.", "The funny thing is getString() already uses getValue().", ":-)", "I think we should get rid of the sections documented with:", "avoid unnecessary object creation if possible", "They add a significant amount of code and I doubt it is worth it.", "The attached patch (JCR-1272.jz.patch) makes all type-specific getters and setters use the generic Value methods.", "The new private getPropertyState() takes care of the sanity check and returns a safe PropertyState reference if the property is OK.", "There still are a number of direct unprotected references to the state variable in PropertyImpl, NodeImpl, and ItemImpl.", "I'm not sure how vulnerable those references are to this error condition.", "Looks good.", "+1", "I'll commit the patch.", "Committed Jukkas patch in revision: 605506"], "SplitGT": [" and returns the underlying property state if all is OK."], "issueString": "Property.getValue() throws RepositoryException with internal error\nRunning ConcurrentReadWriteTest (NUM_NODES=5, NUM_THREADS=3, RUN_NUM_SECONDS=120) resulted in a RepositoryException calling Property.getValue():\n\njavax.jcr.RepositoryException: Internal error while retrieving value of b3fc1ea8-3364-4236-bcc7-dea0baf90640/{}test: null: null\n\nDebugging shows that it is a NullPointerException:\n\njava.lang.NullPointerException\n\tat org.apache.jackrabbit.core.PropertyImpl.getValue(PropertyImpl.java:481)\n\tat org.apache.jackrabbit.core.ConcurrentReadWriteTest$1$1.execute(ConcurrentReadWriteTest.java:68)\n\tat org.apache.jackrabbit.core.AbstractConcurrencyTest$Executor.run(AbstractConcurrencyTest.java:110)\n\tat java.lang.Thread.run(Thread.java:619)\n\nIt's probably the state which has been discarded after the sanityCheck().\nMoved getItemState() to the top of the method. This ensures that the state reference is still valid even if the property is discarded after the sanityCheck().\nWhat about all the other value getters like getString()? I guess we should make them just call getValue() instead of trying to optimize things.\nIn fact there are tons of unguarded code that accesses the state variable. I'll come up with a patch for fixing them all.\nYou are right. The funny thing is getString() already uses getValue(). :-)\n\nI think we should get rid of the sections documented with:\n// avoid unnecessary object creation if possible\n\nThey add a significant amount of code and I doubt it is worth it.\nThe attached patch (JCR-1272.jz.patch) makes all type-specific getters and setters use the generic Value methods.\n\nThe new private getPropertyState() takes care of the sanity check and returns a safe PropertyState reference if the property is OK.\n\nThere still are a number of direct unprotected references to the state variable in PropertyImpl, NodeImpl, and ItemImpl. I'm not sure how vulnerable those references are to this error condition.\nLooks good.\n\n+1\n\nI'll commit the patch.\nCommitted Jukkas patch in revision: 605506\n"}
{"aId": 46, "code": "public UUID nextIdentifier() {\n        return nextUUID(true);\n    }", "comment": " A cryptographically secure pseudorandom number generator is used to generate the values (because otherwise the probability of duplicates may be significantly higher).", "issueId": "JCR-1206", "issueStringList": ["UUID generation: SecureRandom should be used by default", "Currently, the UUID generation used the regular java.util.Random implementation to generate random UUIDs.", "The seed value of Random is initialized using System.currentTimeMillis(); for Windows, the resolution is about 15 milliseconds.", "That means two computer that start creating UUIDs with Jackrabbit within the same 15 millisecond interval will generate the same UUIDs.", "In a clustered environment the nodes could be started automatically at the same time (for example after a backup).", "Also, the Random class uses a 48-bit seed, which is much less than the number of random bits in UUID (122).", "This is not secure.", "See also:", "http://en.wikipedia.org/wiki/UUID", "Random UUID probability of duplicates", "\"The probability [of duplicates] also depends on the quality of the random number generator.", "A cryptographically secure pseudorandom number generator must be used to generate the values, otherwise the probability of duplicates may be significantly higher.\"", "Therefore, I suggest to change VersionFourGenerator to use the SecureRandom implementation in by default.", "Fixed as of revision 594470"], "SplitGT": [" A cryptographically secure pseudorandom number generator is used to generate the values (because otherwise the probability of duplicates may be significantly higher)."], "issueString": "UUID generation: SecureRandom should be used by default\nCurrently, the UUID generation used the regular java.util.Random implementation to generate random UUIDs. The seed value of Random is initialized using System.currentTimeMillis(); for Windows, the resolution is about 15 milliseconds. That means two computer that start creating UUIDs with Jackrabbit within the same 15 millisecond interval will generate the same UUIDs. In a clustered environment the nodes could be started automatically at the same time (for example after a backup).\n\nAlso, the Random class uses a 48-bit seed, which is much less than the number of random bits in UUID (122). This is not secure. See also:\n\nhttp://en.wikipedia.org/wiki/UUID\nRandom UUID probability of duplicates\n\"The probability [of duplicates] also depends on the quality of the random number generator. A cryptographically secure pseudorandom number generator must be used to generate the values, otherwise the probability of duplicates may be significantly higher.\"\n\nTherefore, I suggest to change VersionFourGenerator to use the SecureRandom implementation in by default.\nFixed as of revision 594470\n"}
{"aId": 51, "code": "public Map getNamespaces() throws RepositoryException {\r\n        Map namespaces = new HashMap();\r\n        String[] prefixes = session.getNamespacePrefixes();\r\n        for (int i = 0; i < prefixes.length; i++) {\r\n            namespaces.put(prefixes[i], session.getNamespaceURI(prefixes[i]));\r\n        }\r\n        return namespaces;\r\n    }", "comment": " Returns a map containing all prefix to namespace URI mappings of the current session.", "issueId": "JCR-1607", "issueStringList": ["Add a NamespaceHelper in jcr-commons", "We have a number of code snippets in jackrabbit-core and many JCR clients that do something like the following:", "get the prefix/URI for a given namespace URI/prefix without throwing an exception if the namespace is not found (return null instead)", "get a Map containing all current namespace prefix->URI mappings", "get the prefixed name for a given URI + local name pair in a given session (without a dependency to the SPI)", "safely register a given namespace (don't throw if the namespace is already registered, automatically select an unused prefix if needed, etc.)", "I'd like to introduce a NamespaceHelper class in jcr-commons to cover such common code.", "Resolved in revisions 657026 (impl in jcr-commons), 657028 (use in jcr-commons), 657037 (use in core), and 65738 (use in jcr-server)."], "SplitGT": [" Returns a map containing all prefix to namespace URI mappings of the current session."], "issueString": "Add a NamespaceHelper in jcr-commons\nWe have a number of code snippets in jackrabbit-core and many JCR clients that do something like the following:\n\n* get the prefix/URI for a given namespace URI/prefix without throwing an exception if the namespace is not found (return null instead)\n* get a Map containing all current namespace prefix->URI mappings\n* get the prefixed name for a given URI + local name pair in a given session (without a dependency to the SPI)\n* safely register a given namespace (don't throw if the namespace is already registered, automatically select an unused prefix if needed, etc.)\n\nI'd like to introduce a NamespaceHelper class in jcr-commons to cover such common code.\nResolved in revisions 657026 (impl in jcr-commons), 657028 (use in jcr-commons), 657037 (use in core), and 65738 (use in jcr-server).\n"}
{"aId": 52, "code": "public String getPrefix(String uri) throws RepositoryException {\r\n        try {\r\n            return session.getNamespacePrefix(uri);\r\n        } catch (NamespaceException e) {\r\n            return null;\r\n        }\r\n    }", "comment": " Returns the prefix mapped to the given namespace URI in the current session, or null if the namespace does not exist.", "issueId": "JCR-1607", "issueStringList": ["Add a NamespaceHelper in jcr-commons", "We have a number of code snippets in jackrabbit-core and many JCR clients that do something like the following:", "get the prefix/URI for a given namespace URI/prefix without throwing an exception if the namespace is not found (return null instead)", "get a Map containing all current namespace prefix->URI mappings", "get the prefixed name for a given URI + local name pair in a given session (without a dependency to the SPI)", "safely register a given namespace (don't throw if the namespace is already registered, automatically select an unused prefix if needed, etc.)", "I'd like to introduce a NamespaceHelper class in jcr-commons to cover such common code.", "Resolved in revisions 657026 (impl in jcr-commons), 657028 (use in jcr-commons), 657037 (use in core), and 65738 (use in jcr-server)."], "SplitGT": [" Returns the prefix mapped to the given namespace URI in the current session, or null if the namespace does not exist."], "issueString": "Add a NamespaceHelper in jcr-commons\nWe have a number of code snippets in jackrabbit-core and many JCR clients that do something like the following:\n\n* get the prefix/URI for a given namespace URI/prefix without throwing an exception if the namespace is not found (return null instead)\n* get a Map containing all current namespace prefix->URI mappings\n* get the prefixed name for a given URI + local name pair in a given session (without a dependency to the SPI)\n* safely register a given namespace (don't throw if the namespace is already registered, automatically select an unused prefix if needed, etc.)\n\nI'd like to introduce a NamespaceHelper class in jcr-commons to cover such common code.\nResolved in revisions 657026 (impl in jcr-commons), 657028 (use in jcr-commons), 657037 (use in core), and 65738 (use in jcr-server).\n"}
{"aId": 54, "code": "public static boolean denyAllToEveryone(Session session, String absPath) throws RepositoryException {\n        Principal everyone = getEveryonePrincipal(session);\n        Privilege[] privileges = privilegesFromNames(session, Privilege.JCR_ALL);\n        return addAccessControlEntry(session, absPath, everyone, privileges, false);\n    }", "comment": " Utility to deny jcr:all privilege to the everyone group principal.", "issueId": "JCR-3350", "issueStringList": ["Easy-to-use utility class for adding ACEs to nodes", "There should be any easy (one-line) method for adding an ACE to a node in a repo supporting resource-based ACLs.", "Notes:", "1) Patch was developed (and tested) inside CQ and so may need (hopefully very minor) alterations for inclusion in jackrabbit-jcr-commons.", "2) Patch was developed by a Jackrabbit newbie so should be code-reviewed.", "thanks for the patch i will take a look at it as soon as possible.", "hi jeff,", "i just applied the patch a realized that the utility has an adobe license header and adobe package names.", "that's obviously not", "optimal for apache jackrabbit.", "furthermore the utility methods throw SlingException... there is however not dependency to sling", "in jackrabbit.", "finally the methods implicitly call sesssion.save... while that's useful in certain cases it isn't when it comes to", "request processing that should be atomic.", "in order to cover the latter i would suggest that the method should have an autosave", "flag (or something similar).", "would it be possible for you to revise the patch and maybe create it against the jackrabbit code base?", "thanks a lot!", "Version 2 of the \"pseudo-patch\".", "(I uploaded this one as a plain .java file since it's not really a patch.)", "Hi Angela,", "I've updated the file to include an optional autoSave flag (modelled after the JcrUtil.createPath() routines).", "This required changing the exception processing a little as I can no longer roll the session back (not really a loss as the jackrabbit version is simplified enough over the original CQ code that it isn't doing multiple operations at once anyway).", "I changed the SlingException to a generic unchecked exception.", "I updated the license header, but the package name is fake, as I'm not sure where it should go.", "(I have no jackrabbit sources installed as I'm trying to get all the new CQ/Granite/Sling/Hybris infomation rattling around in my brain to solidify before adding too much new stuff and causing it all to explode.)", "I uploaded it as a naked .java file this time as it's not really a true patch.", "Some comments:", "I would wrap the RepositoryException inside a generic RuntimeException.", "This makes handling unduly hard and inside a Jackrabbit class, it is probably appropriate to have RepositoryExceptions thrown.", "But those should be documented", "Is it required to check for the existence of the item first ?", "In other words, would setting the ACL fail if the item would not exist ?", "What if the item is a property ?", "I would get rid of the autoSave flag and just document this method does not save or rollback at all.", "i slightly refactored the patch and committed it at revision 1362813.", "the utility now provides the following methods:", "privilegesFromNames: to get privilege instances from the name (constants)", "getAccessControlList: to retrieve a modifiable JackrabbitAccessControlList", "addAccessControlEntry: to grant/deny privileges to a given principal at a given path", "grantAllToEveryone: grant jcr:all to the everyone group principal", "denyAllToEveryone: deny jcr:all to the everyone group principal", "all methods throw RepositoryException and none of the method persists any changes made.", "javadoc of the modifying methods explains that Session#save() is required in order to persist", "the modifications.", "as felix stated the Session#itemExists call is rather confusing and doesn't add any value IMO.", "i therefore omitted it altogether and adjusted javadoc: the path parameter is called absPath and", "is defined to be a absolute path of an existing node.", "In case of an invalid path the method with", "throw the appropriate exception such as defined by the JCR access control API."], "SplitGT": [" Utility to deny jcr:all privilege to the everyone group principal."], "issueString": "Easy-to-use utility class for adding ACEs to nodes\nThere should be any easy (one-line) method for adding an ACE to a node in a repo supporting resource-based ACLs.\nNotes:\n\n1) Patch was developed (and tested) inside CQ and so may need (hopefully very minor) alterations for inclusion in jackrabbit-jcr-commons.\n\n2) Patch was developed by a Jackrabbit newbie so should be code-reviewed.\nthanks for the patch i will take a look at it as soon as possible.\nhi jeff,\n\ni just applied the patch a realized that the utility has an adobe license header and adobe package names. that's obviously not\noptimal for apache jackrabbit. furthermore the utility methods throw SlingException... there is however not dependency to sling\nin jackrabbit. finally the methods implicitly call sesssion.save... while that's useful in certain cases it isn't when it comes to\nrequest processing that should be atomic. in order to cover the latter i would suggest that the method should have an autosave\nflag (or something similar).\nwould it be possible for you to revise the patch and maybe create it against the jackrabbit code base? thanks a lot!\nVersion 2 of the \"pseudo-patch\".   (I uploaded this one as a plain .java file since it's not really a patch.)\nHi Angela,\n\nI've updated the file to include an optional autoSave flag (modelled after the JcrUtil.createPath() routines).  This required changing the exception processing a little as I can no longer roll the session back (not really a loss as the jackrabbit version is simplified enough over the original CQ code that it isn't doing multiple operations at once anyway).\n\nI changed the SlingException to a generic unchecked exception.\n\nI updated the license header, but the package name is fake, as I'm not sure where it should go.  (I have no jackrabbit sources installed as I'm trying to get all the new CQ/Granite/Sling/Hybris infomation rattling around in my brain to solidify before adding too much new stuff and causing it all to explode.)\n\nI uploaded it as a naked .java file this time as it's not really a true patch.\nSome comments:\n* I would wrap the RepositoryException inside a generic RuntimeException. This makes handling unduly hard and inside a Jackrabbit class, it is probably appropriate to have RepositoryExceptions thrown. But those should be documented\n* Is it required to check for the existence of the item first ? In other words, would setting the ACL fail if the item would not exist ? What if the item is a property ?\n* I would get rid of the autoSave flag and just document this method does not save or rollback at all.\ni slightly refactored the patch and committed it at revision 1362813.\n\nthe utility now provides the following methods:\n- privilegesFromNames: to get privilege instances from the name (constants)\n- getAccessControlList: to retrieve a modifiable JackrabbitAccessControlList\n- addAccessControlEntry: to grant/deny privileges to a given principal at a given path\n- grantAllToEveryone: grant jcr:all to the everyone group principal\n- denyAllToEveryone: deny jcr:all to the everyone group principal\n\nall methods throw RepositoryException and none of the method persists any changes made.\njavadoc of the modifying methods explains that Session#save() is required in order to persist \nthe modifications.\n\nas felix stated the Session#itemExists call is rather confusing and doesn't add any value IMO.\ni therefore omitted it altogether and adjusted javadoc: the path parameter is called absPath and\nis defined to be a absolute path of an existing node. In case of an invalid path the method with\nthrow the appropriate exception such as defined by the JCR access control API.\n"}
{"aId": 55, "code": "private Literal getUncastLiteralSpecCompliant(Value value) throws RepositoryException {\n        return factory.literal(valueFactory.createValue(value.getString()));\n    }", "comment": " Create uncast literal from a value. According to the JCR specification, \"an UncastLiteral is always interpreted as a Value of property type STRING\" (JCR 2.0 Core Specification, 6.7.34 Literal, page 124). That means the value is converted to a String first.", "issueId": "JCR-2282", "issueStringList": ["SQL2 parser may infer type for UncastLiteral from static analysis", "The spec says:", "\"An UncastLiteral is always interpreted as a Value of property type STRING.", "A CastLiteral, on the other hand, is interpreted as the string form of a Value of the PropertyType indicated.\"", "There are also two test cases in NodeNameTest that need to be fixed accordingly: testLongLiteral and testBooleanLiteral", "The specification I have (jcr-spec.pdf from content_repository-2_0-pfd-spec.zip) says:", "UnquotedLiteral ::= /* String form of a JCR Value, as defined in \u00a73.5.4 Conversion of Values */", "However there is no section 3.5.4.", "I guess it should be \"3.6.4 Property Type Conversion\" instead.", "Right, and right after that is the section I was referring to.", "Index: src/main/java/org/apache/jackrabbit/test/api/query/qom/NodeNameTest.java", "===================================================================", "src/main/java/org/apache/jackrabbit/test/api/query/qom/NodeNameTest.java\t(revision 808318)", "+++ src/main/java/org/apache/jackrabbit/test/api/query/qom/NodeNameTest.java\t(working copy)", "@@ -144,7 +144,7 @@", "}", "try {", "String stmt = \"SELECT * FROM [\" + testNodeType + \"] AS s \" +", "\"WHERE NAME(s) = \" + literal.getString();", "+                    \"WHERE NAME(s) = CAST(\" + literal.getString() + \" AS LONG)\";", "qm.createQuery(stmt, Query.JCR_SQL2).execute();", "fail(\"NAME() comparison with LONG must fail with InvalidQueryException\");", "} catch (InvalidQueryException e) {", "@@ -162,10 +162,11 @@", "}", "try {", "String stmt = \"SELECT * FROM [\" + testNodeType + \"] AS s \" +", "\"WHERE NAME(s) = \" + literal.getString();", "+                    \"WHERE NAME(s) = CAST(\" + literal.getString() + \" AS BOOLEAN)\";", "qm.createQuery(stmt, Query.JCR_SQL2).execute();", "fail(\"NAME() comparison with BOOLEAN must fail with InvalidQueryException\");", "} catch (InvalidQueryException e) {", "+            e.printStackTrace();", "expected", "}", "}", "Index: src/main/java/org/apache/jackrabbit/spi/commons/query/sql2/Parser.java", "===================================================================", "src/main/java/org/apache/jackrabbit/spi/commons/query/sql2/Parser.java\t(revision 808318)", "+++ src/main/java/org/apache/jackrabbit/spi/commons/query/sql2/Parser.java\t(working copy)", "@@ -19,7 +19,6 @@", "import java.math.BigDecimal;", "import java.util.ArrayList;", "import java.util.HashMap;", "import javax.jcr.PropertyType;", "import javax.jcr.RepositoryException;", "import javax.jcr.Value;", "@@ -39,7 +38,6 @@", "import javax.jcr.query.qom.Selector;", "import javax.jcr.query.qom.Source;", "import javax.jcr.query.qom.StaticOperand;", "import org.apache.jackrabbit.spi.commons.query.qom.JoinType;", "import org.apache.jackrabbit.spi.commons.query.qom.Operator;", "@@ -455,7 +453,7 @@", "}", "}", "if (currentTokenType == VALUE) {", "Literal literal = factory.literal(currentValue);", "+            Literal literal = getUncastLiteral(currentValue);", "read();", "return literal;", "} else if (currentTokenType == PARAMETER) {", "@@ -471,10 +469,10 @@", "}", "return var;", "} else if (readIf(\"TRUE\")) {", "Literal literal = factory.literal(valueFactory.createValue(true));", "+            Literal literal = getUncastLiteral(valueFactory.createValue(true));", "return literal;", "} else if (readIf(\"FALSE\")) {", "Literal literal = factory.literal(valueFactory.createValue(false));", "+            Literal literal = getUncastLiteral(valueFactory.createValue(false));", "return literal;", "} else if (readIf(\"CAST\")) {", "read(\"(\");", "@@ -487,6 +485,7 @@", "read(\"AS\");", "value = parseCastAs(value);", "read(\")\");", "+            // CastLiteral", "literal = factory.literal(value);", "return literal;", "} else {", "@@ -494,6 +493,19 @@", "}", "}", "+    /**", "+     * Create uncast literal from a value.", "According to the JCR specification,", "+     * \"an UncastLiteral is always interpreted as a Value of property type STRING\"", "+     * (JCR 2.0 Core Specification, 6.7.34 Literal, page 124).", "+     * That means the value is converted to a String first.", "+     *", "+     * @param value the original value", "+     * @return the literal", "+     */", "+    private Literal getUncastLiteral(Value value) throws RepositoryException {", "+        return factory.literal(valueFactory.createValue(value.getString()));", "+    }", "+", "private Value parseCastAs(Value value) throws RepositoryException {", "if (readIf(\"STRING\")) {", "return valueFactory.createValue(value.getString());", "e.printStackTrace();", "+1, looks good.", "Because of this change the build now fails with", "javax.jcr.query.InvalidQueryException: Static value 3.0 cannot be converted to a Long", "for the query:", "SELECT * FROM [nt:unstructured] AS s WHERE ISCHILDNODE(s, [/testroot]) AND LENGTH(s.prop1) = 3.0", "3.0 used to be parsed as a BigDecimal, and could be converted to a Long.", "Now 3.0 is parsed as a String (actually first parsed as a BigDecimal and then converted to a String by the parser).", "Long.parseLong(\"3.0\") fails.", "If you want the query to work, you could write:", "... AND LENGTH(s.prop1) = CAST(3.0 AS DOUBLE).", "I think we should rather change the spec than trying to build a workaround.", "It's weird that the parser should read 3.0 to a String, and only as a double if you write CAST(3.0 AS DOUBLE).", "I filed a bug yesterday: https://jsr-283.dev.java.net/issues/show_bug.cgi?id=806", "So I suggest to undo my commit, and change the spec instead."], "SplitGT": [" Create uncast literal from a value.", "According to the JCR specification, \"an UncastLiteral is always interpreted as a Value of property type STRING\" (JCR 2.0 Core Specification, 6.7.34 Literal, page 124).", "That means the value is converted to a String first."], "issueString": "SQL2 parser may infer type for UncastLiteral from static analysis\nThe spec says:\n\n\"An UncastLiteral is always interpreted as a Value of property type STRING. A CastLiteral, on the other hand, is interpreted as the string form of a Value of the PropertyType indicated.\"\n\nThere are also two test cases in NodeNameTest that need to be fixed accordingly: testLongLiteral and testBooleanLiteral\n\nThe specification I have (jcr-spec.pdf from content_repository-2_0-pfd-spec.zip) says:\nUnquotedLiteral ::= /* String form of a JCR Value, as defined in \u00a73.5.4 Conversion of Values */\nHowever there is no section 3.5.4. I guess it should be \"3.6.4 Property Type Conversion\" instead.\n\nRight, and right after that is the section I was referring to.\nIndex: src/main/java/org/apache/jackrabbit/test/api/query/qom/NodeNameTest.java\n===================================================================\n--- src/main/java/org/apache/jackrabbit/test/api/query/qom/NodeNameTest.java\t(revision 808318)\n+++ src/main/java/org/apache/jackrabbit/test/api/query/qom/NodeNameTest.java\t(working copy)\n@@ -144,7 +144,7 @@\n         }\n         try {\n             String stmt = \"SELECT * FROM [\" + testNodeType + \"] AS s \" +\n-                    \"WHERE NAME(s) = \" + literal.getString();\n+                    \"WHERE NAME(s) = CAST(\" + literal.getString() + \" AS LONG)\";\n             qm.createQuery(stmt, Query.JCR_SQL2).execute();\n             fail(\"NAME() comparison with LONG must fail with InvalidQueryException\");\n         } catch (InvalidQueryException e) {\n@@ -162,10 +162,11 @@\n         }\n         try {\n             String stmt = \"SELECT * FROM [\" + testNodeType + \"] AS s \" +\n-                    \"WHERE NAME(s) = \" + literal.getString();\n+                    \"WHERE NAME(s) = CAST(\" + literal.getString() + \" AS BOOLEAN)\";\n             qm.createQuery(stmt, Query.JCR_SQL2).execute();\n             fail(\"NAME() comparison with BOOLEAN must fail with InvalidQueryException\");\n         } catch (InvalidQueryException e) {\n+            e.printStackTrace();\n             // expected\n         }\n     }\n\n\nIndex: src/main/java/org/apache/jackrabbit/spi/commons/query/sql2/Parser.java\n===================================================================\n--- src/main/java/org/apache/jackrabbit/spi/commons/query/sql2/Parser.java\t(revision 808318)\n+++ src/main/java/org/apache/jackrabbit/spi/commons/query/sql2/Parser.java\t(working copy)\n@@ -19,7 +19,6 @@\n import java.math.BigDecimal;\n import java.util.ArrayList;\n import java.util.HashMap;\n-\n import javax.jcr.PropertyType;\n import javax.jcr.RepositoryException;\n import javax.jcr.Value;\n@@ -39,7 +38,6 @@\n import javax.jcr.query.qom.Selector;\n import javax.jcr.query.qom.Source;\n import javax.jcr.query.qom.StaticOperand;\n-\n import org.apache.jackrabbit.spi.commons.query.qom.JoinType;\n import org.apache.jackrabbit.spi.commons.query.qom.Operator;\n \n@@ -455,7 +453,7 @@\n             }\n         }\n         if (currentTokenType == VALUE) {\n-            Literal literal = factory.literal(currentValue);\n+            Literal literal = getUncastLiteral(currentValue);\n             read();\n             return literal;\n         } else if (currentTokenType == PARAMETER) {\n@@ -471,10 +469,10 @@\n             }\n             return var;\n         } else if (readIf(\"TRUE\")) {\n-            Literal literal = factory.literal(valueFactory.createValue(true));\n+            Literal literal = getUncastLiteral(valueFactory.createValue(true));\n             return literal;\n         } else if (readIf(\"FALSE\")) {\n-            Literal literal = factory.literal(valueFactory.createValue(false));\n+            Literal literal = getUncastLiteral(valueFactory.createValue(false));\n             return literal;\n         } else if (readIf(\"CAST\")) {\n             read(\"(\");\n@@ -487,6 +485,7 @@\n             read(\"AS\");\n             value = parseCastAs(value);\n             read(\")\");\n+            // CastLiteral\n             literal = factory.literal(value);\n             return literal;\n         } else {\n@@ -494,6 +493,19 @@\n         }\n     }\n \n+    /**\n+     * Create uncast literal from a value. According to the JCR specification,\n+     * \"an UncastLiteral is always interpreted as a Value of property type STRING\"\n+     * (JCR 2.0 Core Specification, 6.7.34 Literal, page 124).\n+     * That means the value is converted to a String first.\n+     *\n+     * @param value the original value\n+     * @return the literal\n+     */\n+    private Literal getUncastLiteral(Value value) throws RepositoryException {\n+        return factory.literal(valueFactory.createValue(value.getString()));\n+    }\n+\n     private Value parseCastAs(Value value) throws RepositoryException {\n         if (readIf(\"STRING\")) {\n             return valueFactory.createValue(value.getString());\n\n- e.printStackTrace(); \n+1, looks good.\nBecause of this change the build now fails with\n\njavax.jcr.query.InvalidQueryException: Static value 3.0 cannot be converted to a Long\nfor the query:\nSELECT * FROM [nt:unstructured] AS s WHERE ISCHILDNODE(s, [/testroot]) AND LENGTH(s.prop1) = 3.0\n\n3.0 used to be parsed as a BigDecimal, and could be converted to a Long.\nNow 3.0 is parsed as a String (actually first parsed as a BigDecimal and then converted to a String by the parser).\nLong.parseLong(\"3.0\") fails.\n\nIf you want the query to work, you could write:\n... AND LENGTH(s.prop1) = CAST(3.0 AS DOUBLE).\n\nI think we should rather change the spec than trying to build a workaround.\nIt's weird that the parser should read 3.0 to a String, and only as a double if you write CAST(3.0 AS DOUBLE).\n\nI filed a bug yesterday: https://jsr-283.dev.java.net/issues/show_bug.cgi?id=806\n\nSo I suggest to undo my commit, and change the spec instead.\n"}
{"aId": 56, "code": "private Literal getUncastLiteral(Value value) throws RepositoryException {\n        return factory.literal(valueFactory.createValue(value.getString()));\n    }", "comment": " Create uncast literal from a value. According to the JCR specification, \"an UncastLiteral is always interpreted as a Value of property type STRING\" (JCR 2.0 Core Specification, 6.7.34 Literal, page 124). That means the value is converted to a String first.", "issueId": "JCR-2282", "issueStringList": ["SQL2 parser may infer type for UncastLiteral from static analysis", "The spec says:", "\"An UncastLiteral is always interpreted as a Value of property type STRING.", "A CastLiteral, on the other hand, is interpreted as the string form of a Value of the PropertyType indicated.\"", "There are also two test cases in NodeNameTest that need to be fixed accordingly: testLongLiteral and testBooleanLiteral", "The specification I have (jcr-spec.pdf from content_repository-2_0-pfd-spec.zip) says:", "UnquotedLiteral ::= /* String form of a JCR Value, as defined in \u00a73.5.4 Conversion of Values */", "However there is no section 3.5.4.", "I guess it should be \"3.6.4 Property Type Conversion\" instead.", "Right, and right after that is the section I was referring to.", "Index: src/main/java/org/apache/jackrabbit/test/api/query/qom/NodeNameTest.java", "===================================================================", "src/main/java/org/apache/jackrabbit/test/api/query/qom/NodeNameTest.java\t(revision 808318)", "+++ src/main/java/org/apache/jackrabbit/test/api/query/qom/NodeNameTest.java\t(working copy)", "@@ -144,7 +144,7 @@", "}", "try {", "String stmt = \"SELECT * FROM [\" + testNodeType + \"] AS s \" +", "\"WHERE NAME(s) = \" + literal.getString();", "+                    \"WHERE NAME(s) = CAST(\" + literal.getString() + \" AS LONG)\";", "qm.createQuery(stmt, Query.JCR_SQL2).execute();", "fail(\"NAME() comparison with LONG must fail with InvalidQueryException\");", "} catch (InvalidQueryException e) {", "@@ -162,10 +162,11 @@", "}", "try {", "String stmt = \"SELECT * FROM [\" + testNodeType + \"] AS s \" +", "\"WHERE NAME(s) = \" + literal.getString();", "+                    \"WHERE NAME(s) = CAST(\" + literal.getString() + \" AS BOOLEAN)\";", "qm.createQuery(stmt, Query.JCR_SQL2).execute();", "fail(\"NAME() comparison with BOOLEAN must fail with InvalidQueryException\");", "} catch (InvalidQueryException e) {", "+            e.printStackTrace();", "expected", "}", "}", "Index: src/main/java/org/apache/jackrabbit/spi/commons/query/sql2/Parser.java", "===================================================================", "src/main/java/org/apache/jackrabbit/spi/commons/query/sql2/Parser.java\t(revision 808318)", "+++ src/main/java/org/apache/jackrabbit/spi/commons/query/sql2/Parser.java\t(working copy)", "@@ -19,7 +19,6 @@", "import java.math.BigDecimal;", "import java.util.ArrayList;", "import java.util.HashMap;", "import javax.jcr.PropertyType;", "import javax.jcr.RepositoryException;", "import javax.jcr.Value;", "@@ -39,7 +38,6 @@", "import javax.jcr.query.qom.Selector;", "import javax.jcr.query.qom.Source;", "import javax.jcr.query.qom.StaticOperand;", "import org.apache.jackrabbit.spi.commons.query.qom.JoinType;", "import org.apache.jackrabbit.spi.commons.query.qom.Operator;", "@@ -455,7 +453,7 @@", "}", "}", "if (currentTokenType == VALUE) {", "Literal literal = factory.literal(currentValue);", "+            Literal literal = getUncastLiteral(currentValue);", "read();", "return literal;", "} else if (currentTokenType == PARAMETER) {", "@@ -471,10 +469,10 @@", "}", "return var;", "} else if (readIf(\"TRUE\")) {", "Literal literal = factory.literal(valueFactory.createValue(true));", "+            Literal literal = getUncastLiteral(valueFactory.createValue(true));", "return literal;", "} else if (readIf(\"FALSE\")) {", "Literal literal = factory.literal(valueFactory.createValue(false));", "+            Literal literal = getUncastLiteral(valueFactory.createValue(false));", "return literal;", "} else if (readIf(\"CAST\")) {", "read(\"(\");", "@@ -487,6 +485,7 @@", "read(\"AS\");", "value = parseCastAs(value);", "read(\")\");", "+            // CastLiteral", "literal = factory.literal(value);", "return literal;", "} else {", "@@ -494,6 +493,19 @@", "}", "}", "+    /**", "+     * Create uncast literal from a value.", "According to the JCR specification,", "+     * \"an UncastLiteral is always interpreted as a Value of property type STRING\"", "+     * (JCR 2.0 Core Specification, 6.7.34 Literal, page 124).", "+     * That means the value is converted to a String first.", "+     *", "+     * @param value the original value", "+     * @return the literal", "+     */", "+    private Literal getUncastLiteral(Value value) throws RepositoryException {", "+        return factory.literal(valueFactory.createValue(value.getString()));", "+    }", "+", "private Value parseCastAs(Value value) throws RepositoryException {", "if (readIf(\"STRING\")) {", "return valueFactory.createValue(value.getString());", "e.printStackTrace();", "+1, looks good."], "SplitGT": [" Create uncast literal from a value.", "According to the JCR specification, \"an UncastLiteral is always interpreted as a Value of property type STRING\" (JCR 2.0 Core Specification, 6.7.34 Literal, page 124).", "That means the value is converted to a String first."], "issueString": "SQL2 parser may infer type for UncastLiteral from static analysis\nThe spec says:\n\n\"An UncastLiteral is always interpreted as a Value of property type STRING. A CastLiteral, on the other hand, is interpreted as the string form of a Value of the PropertyType indicated.\"\n\nThere are also two test cases in NodeNameTest that need to be fixed accordingly: testLongLiteral and testBooleanLiteral\n\nThe specification I have (jcr-spec.pdf from content_repository-2_0-pfd-spec.zip) says:\nUnquotedLiteral ::= /* String form of a JCR Value, as defined in \u00a73.5.4 Conversion of Values */\nHowever there is no section 3.5.4. I guess it should be \"3.6.4 Property Type Conversion\" instead.\n\nRight, and right after that is the section I was referring to.\nIndex: src/main/java/org/apache/jackrabbit/test/api/query/qom/NodeNameTest.java\n===================================================================\n--- src/main/java/org/apache/jackrabbit/test/api/query/qom/NodeNameTest.java\t(revision 808318)\n+++ src/main/java/org/apache/jackrabbit/test/api/query/qom/NodeNameTest.java\t(working copy)\n@@ -144,7 +144,7 @@\n         }\n         try {\n             String stmt = \"SELECT * FROM [\" + testNodeType + \"] AS s \" +\n-                    \"WHERE NAME(s) = \" + literal.getString();\n+                    \"WHERE NAME(s) = CAST(\" + literal.getString() + \" AS LONG)\";\n             qm.createQuery(stmt, Query.JCR_SQL2).execute();\n             fail(\"NAME() comparison with LONG must fail with InvalidQueryException\");\n         } catch (InvalidQueryException e) {\n@@ -162,10 +162,11 @@\n         }\n         try {\n             String stmt = \"SELECT * FROM [\" + testNodeType + \"] AS s \" +\n-                    \"WHERE NAME(s) = \" + literal.getString();\n+                    \"WHERE NAME(s) = CAST(\" + literal.getString() + \" AS BOOLEAN)\";\n             qm.createQuery(stmt, Query.JCR_SQL2).execute();\n             fail(\"NAME() comparison with BOOLEAN must fail with InvalidQueryException\");\n         } catch (InvalidQueryException e) {\n+            e.printStackTrace();\n             // expected\n         }\n     }\n\n\nIndex: src/main/java/org/apache/jackrabbit/spi/commons/query/sql2/Parser.java\n===================================================================\n--- src/main/java/org/apache/jackrabbit/spi/commons/query/sql2/Parser.java\t(revision 808318)\n+++ src/main/java/org/apache/jackrabbit/spi/commons/query/sql2/Parser.java\t(working copy)\n@@ -19,7 +19,6 @@\n import java.math.BigDecimal;\n import java.util.ArrayList;\n import java.util.HashMap;\n-\n import javax.jcr.PropertyType;\n import javax.jcr.RepositoryException;\n import javax.jcr.Value;\n@@ -39,7 +38,6 @@\n import javax.jcr.query.qom.Selector;\n import javax.jcr.query.qom.Source;\n import javax.jcr.query.qom.StaticOperand;\n-\n import org.apache.jackrabbit.spi.commons.query.qom.JoinType;\n import org.apache.jackrabbit.spi.commons.query.qom.Operator;\n \n@@ -455,7 +453,7 @@\n             }\n         }\n         if (currentTokenType == VALUE) {\n-            Literal literal = factory.literal(currentValue);\n+            Literal literal = getUncastLiteral(currentValue);\n             read();\n             return literal;\n         } else if (currentTokenType == PARAMETER) {\n@@ -471,10 +469,10 @@\n             }\n             return var;\n         } else if (readIf(\"TRUE\")) {\n-            Literal literal = factory.literal(valueFactory.createValue(true));\n+            Literal literal = getUncastLiteral(valueFactory.createValue(true));\n             return literal;\n         } else if (readIf(\"FALSE\")) {\n-            Literal literal = factory.literal(valueFactory.createValue(false));\n+            Literal literal = getUncastLiteral(valueFactory.createValue(false));\n             return literal;\n         } else if (readIf(\"CAST\")) {\n             read(\"(\");\n@@ -487,6 +485,7 @@\n             read(\"AS\");\n             value = parseCastAs(value);\n             read(\")\");\n+            // CastLiteral\n             literal = factory.literal(value);\n             return literal;\n         } else {\n@@ -494,6 +493,19 @@\n         }\n     }\n \n+    /**\n+     * Create uncast literal from a value. According to the JCR specification,\n+     * \"an UncastLiteral is always interpreted as a Value of property type STRING\"\n+     * (JCR 2.0 Core Specification, 6.7.34 Literal, page 124).\n+     * That means the value is converted to a String first.\n+     *\n+     * @param value the original value\n+     * @return the literal\n+     */\n+    private Literal getUncastLiteral(Value value) throws RepositoryException {\n+        return factory.literal(valueFactory.createValue(value.getString()));\n+    }\n+\n     private Value parseCastAs(Value value) throws RepositoryException {\n         if (readIf(\"STRING\")) {\n             return valueFactory.createValue(value.getString());\n\n- e.printStackTrace(); \n+1, looks good.\n"}
{"aId": 57, "code": "public static boolean grantAllToEveryone(Session session, String absPath) throws RepositoryException {\n        Principal everyone = getEveryonePrincipal(session);\n        Privilege[] privileges = privilegesFromNames(session, Privilege.JCR_ALL);\n        return addAccessControlEntry(session, absPath, everyone, privileges, true);\n    }", "comment": " Utility to grant jcr:all privilege to the everyone group principal.", "issueId": "JCR-3350", "issueStringList": ["Easy-to-use utility class for adding ACEs to nodes", "There should be any easy (one-line) method for adding an ACE to a node in a repo supporting resource-based ACLs.", "Notes:", "1) Patch was developed (and tested) inside CQ and so may need (hopefully very minor) alterations for inclusion in jackrabbit-jcr-commons.", "2) Patch was developed by a Jackrabbit newbie so should be code-reviewed.", "thanks for the patch i will take a look at it as soon as possible.", "hi jeff,", "i just applied the patch a realized that the utility has an adobe license header and adobe package names.", "that's obviously not", "optimal for apache jackrabbit.", "furthermore the utility methods throw SlingException... there is however not dependency to sling", "in jackrabbit.", "finally the methods implicitly call sesssion.save... while that's useful in certain cases it isn't when it comes to", "request processing that should be atomic.", "in order to cover the latter i would suggest that the method should have an autosave", "flag (or something similar).", "would it be possible for you to revise the patch and maybe create it against the jackrabbit code base?", "thanks a lot!", "Version 2 of the \"pseudo-patch\".", "(I uploaded this one as a plain .java file since it's not really a patch.)", "Hi Angela,", "I've updated the file to include an optional autoSave flag (modelled after the JcrUtil.createPath() routines).", "This required changing the exception processing a little as I can no longer roll the session back (not really a loss as the jackrabbit version is simplified enough over the original CQ code that it isn't doing multiple operations at once anyway).", "I changed the SlingException to a generic unchecked exception.", "I updated the license header, but the package name is fake, as I'm not sure where it should go.", "(I have no jackrabbit sources installed as I'm trying to get all the new CQ/Granite/Sling/Hybris infomation rattling around in my brain to solidify before adding too much new stuff and causing it all to explode.)", "I uploaded it as a naked .java file this time as it's not really a true patch.", "Some comments:", "I would wrap the RepositoryException inside a generic RuntimeException.", "This makes handling unduly hard and inside a Jackrabbit class, it is probably appropriate to have RepositoryExceptions thrown.", "But those should be documented", "Is it required to check for the existence of the item first ?", "In other words, would setting the ACL fail if the item would not exist ?", "What if the item is a property ?", "I would get rid of the autoSave flag and just document this method does not save or rollback at all.", "i slightly refactored the patch and committed it at revision 1362813.", "the utility now provides the following methods:", "privilegesFromNames: to get privilege instances from the name (constants)", "getAccessControlList: to retrieve a modifiable JackrabbitAccessControlList", "addAccessControlEntry: to grant/deny privileges to a given principal at a given path", "grantAllToEveryone: grant jcr:all to the everyone group principal", "denyAllToEveryone: deny jcr:all to the everyone group principal", "all methods throw RepositoryException and none of the method persists any changes made.", "javadoc of the modifying methods explains that Session#save() is required in order to persist", "the modifications.", "as felix stated the Session#itemExists call is rather confusing and doesn't add any value IMO.", "i therefore omitted it altogether and adjusted javadoc: the path parameter is called absPath and", "is defined to be a absolute path of an existing node.", "In case of an invalid path the method with", "throw the appropriate exception such as defined by the JCR access control API."], "SplitGT": [" Utility to grant jcr:all privilege to the everyone group principal."], "issueString": "Easy-to-use utility class for adding ACEs to nodes\nThere should be any easy (one-line) method for adding an ACE to a node in a repo supporting resource-based ACLs.\nNotes:\n\n1) Patch was developed (and tested) inside CQ and so may need (hopefully very minor) alterations for inclusion in jackrabbit-jcr-commons.\n\n2) Patch was developed by a Jackrabbit newbie so should be code-reviewed.\nthanks for the patch i will take a look at it as soon as possible.\nhi jeff,\n\ni just applied the patch a realized that the utility has an adobe license header and adobe package names. that's obviously not\noptimal for apache jackrabbit. furthermore the utility methods throw SlingException... there is however not dependency to sling\nin jackrabbit. finally the methods implicitly call sesssion.save... while that's useful in certain cases it isn't when it comes to\nrequest processing that should be atomic. in order to cover the latter i would suggest that the method should have an autosave\nflag (or something similar).\nwould it be possible for you to revise the patch and maybe create it against the jackrabbit code base? thanks a lot!\nVersion 2 of the \"pseudo-patch\".   (I uploaded this one as a plain .java file since it's not really a patch.)\nHi Angela,\n\nI've updated the file to include an optional autoSave flag (modelled after the JcrUtil.createPath() routines).  This required changing the exception processing a little as I can no longer roll the session back (not really a loss as the jackrabbit version is simplified enough over the original CQ code that it isn't doing multiple operations at once anyway).\n\nI changed the SlingException to a generic unchecked exception.\n\nI updated the license header, but the package name is fake, as I'm not sure where it should go.  (I have no jackrabbit sources installed as I'm trying to get all the new CQ/Granite/Sling/Hybris infomation rattling around in my brain to solidify before adding too much new stuff and causing it all to explode.)\n\nI uploaded it as a naked .java file this time as it's not really a true patch.\nSome comments:\n* I would wrap the RepositoryException inside a generic RuntimeException. This makes handling unduly hard and inside a Jackrabbit class, it is probably appropriate to have RepositoryExceptions thrown. But those should be documented\n* Is it required to check for the existence of the item first ? In other words, would setting the ACL fail if the item would not exist ? What if the item is a property ?\n* I would get rid of the autoSave flag and just document this method does not save or rollback at all.\ni slightly refactored the patch and committed it at revision 1362813.\n\nthe utility now provides the following methods:\n- privilegesFromNames: to get privilege instances from the name (constants)\n- getAccessControlList: to retrieve a modifiable JackrabbitAccessControlList\n- addAccessControlEntry: to grant/deny privileges to a given principal at a given path\n- grantAllToEveryone: grant jcr:all to the everyone group principal\n- denyAllToEveryone: deny jcr:all to the everyone group principal\n\nall methods throw RepositoryException and none of the method persists any changes made.\njavadoc of the modifying methods explains that Session#save() is required in order to persist \nthe modifications.\n\nas felix stated the Session#itemExists call is rather confusing and doesn't add any value IMO.\ni therefore omitted it altogether and adjusted javadoc: the path parameter is called absPath and\nis defined to be a absolute path of an existing node. In case of an invalid path the method with\nthrow the appropriate exception such as defined by the JCR access control API.\n"}
{"aId": 58, "code": "public Properties getNamespaces() {\r\n        return namespaces;\r\n    }", "comment": " Returns the namespaces declared in the node type definition file.", "issueId": "JCR-142", "issueStringList": ["allow subclassing of NodeTypeReader", "in working towards an offline tool to import custom namespaces and node types, i found that i needed to make some small changes to NodeTypeReader and DOMWalker so that i could subclass NodeTypeReader and access the namespaces specified in the node type definition file.", "see the attached patch.", "any comments on this issue?", "these changes have been very useful to me in building a command line tool that can register custom namespaces and nodetypes in a repository (see http://svn.osafoundation.org/server/commons/trunk/jackrabbit/)."], "SplitGT": [" Returns the namespaces declared in the node type definition file."], "issueString": "allow subclassing of NodeTypeReader\nin working towards an offline tool to import custom namespaces and node types, i found that i needed to make some small changes to NodeTypeReader and DOMWalker so that i could subclass NodeTypeReader and access the namespaces specified in the node type definition file. see the attached patch.\n\nany comments on this issue? these changes have been very useful to me in building a command line tool that can register custom namespaces and nodetypes in a repository (see http://svn.osafoundation.org/server/commons/trunk/jackrabbit/).\n"}
{"aId": 59, "code": "public static RepositoryConfig create(File dir)\n            throws ConfigurationException {\n        return create(new File(dir, REPOSITORY_XML), dir);\n    }", "comment": " Returns the configuration of a repository in a given repository directory. The repository configuration is read from a \"repository.xml\" file inside the repository directory.", "issueId": "JCR-2119", "issueStringList": ["Method to create default RepositoryConfig from just the repository directory", "It would be useful to have a static method like RepositoryConfig.create(File) that would take the repository directory and expect to find the repository configuration in a \"repository.xml\" file inside that directory.", "If the directory does not exist, it would be created.", "And if the repository configuration file does not exist, then it would be created from the default configuration included in Jackrabbit.", "Added the following methods in revision 776310:", "RepositoryConfig.install(File dir);", "RepostiroyConfig.install(File xml, File dir);", "RepositoryConfig.create(File dir);", "RepositoryConfig.create(File xml, File dir);", "The install() methods will automatically create the repository directory and configuration file if they do not already exist.", "The create() methods will fail with an exception in the same situation."], "SplitGT": [" Returns the configuration of a repository in a given repository directory.", "The repository configuration is read from a \"repository.xml\" file inside the repository directory."], "issueString": "Method to create default RepositoryConfig from just the repository directory\nIt would be useful to have a static method like RepositoryConfig.create(File) that would take the repository directory and expect to find the repository configuration in a \"repository.xml\" file inside that directory.\n\nIf the directory does not exist, it would be created. And if the repository configuration file does not exist, then it would be created from the default configuration included in Jackrabbit.\nAdded the following methods in revision 776310:\n\n   RepositoryConfig.install(File dir);\n   RepostiroyConfig.install(File xml, File dir);\n   RepositoryConfig.create(File dir);\n   RepositoryConfig.create(File xml, File dir);\n\nThe install() methods will automatically create the repository directory and configuration file if they do not already exist. The create() methods will fail with an exception in the same situation.\n"}
{"aId": 60, "code": "public String getURI(String prefix) throws RepositoryException {\r\n        try {\r\n            return session.getNamespaceURI(prefix);\r\n        } catch (NamespaceException e) {\r\n            return null;\r\n        }\r\n    }", "comment": " Returns the namespace URI mapped to the given prefix in the current session, or null if the namespace does not exist.", "issueId": "JCR-1607", "issueStringList": ["Add a NamespaceHelper in jcr-commons", "We have a number of code snippets in jackrabbit-core and many JCR clients that do something like the following:", "get the prefix/URI for a given namespace URI/prefix without throwing an exception if the namespace is not found (return null instead)", "get a Map containing all current namespace prefix->URI mappings", "get the prefixed name for a given URI + local name pair in a given session (without a dependency to the SPI)", "safely register a given namespace (don't throw if the namespace is already registered, automatically select an unused prefix if needed, etc.)", "I'd like to introduce a NamespaceHelper class in jcr-commons to cover such common code.", "Resolved in revisions 657026 (impl in jcr-commons), 657028 (use in jcr-commons), 657037 (use in core), and 65738 (use in jcr-server)."], "SplitGT": [" Returns the namespace URI mapped to the given prefix in the current session, or null if the namespace does not exist."], "issueString": "Add a NamespaceHelper in jcr-commons\nWe have a number of code snippets in jackrabbit-core and many JCR clients that do something like the following:\n\n* get the prefix/URI for a given namespace URI/prefix without throwing an exception if the namespace is not found (return null instead)\n* get a Map containing all current namespace prefix->URI mappings\n* get the prefixed name for a given URI + local name pair in a given session (without a dependency to the SPI)\n* safely register a given namespace (don't throw if the namespace is already registered, automatically select an unused prefix if needed, etc.)\n\nI'd like to introduce a NamespaceHelper class in jcr-commons to cover such common code.\nResolved in revisions 657026 (impl in jcr-commons), 657028 (use in jcr-commons), 657037 (use in core), and 65738 (use in jcr-server).\n"}
{"aId": 64, "code": "protected void checkUnlock(LockInfo info, Session session)\n    \t\tthrows LockException, RepositoryException {\n    \t\n\t    if (!info.isLockHolder(session)) {\n\t        throw new LockException(\"Node not locked by session: \" + info.getId());\n\t    }\n    }", "comment": " Check whether a session is allowed to unlock a node.", "issueId": "JCR-2183", "issueStringList": ["Provide overridables for lock checking", "Currently, checking whether a session is allowed to write to some locked node or whether it is allowed to unlock it is quite spread throughout the code.", "This should be collected to allow a custom lock manager overriding just a few methods to alter the default behavior.", "Fixed in revision 790892."], "SplitGT": [" Check whether a session is allowed to unlock a node."], "issueString": "Provide overridables for lock checking\nCurrently, checking whether a session is allowed to write to some locked node or whether it is allowed to unlock it is quite spread throughout the code. This should be collected to allow a custom lock manager overriding just a few methods to alter the default behavior.\nFixed in revision 790892.\n"}
{"aId": 65, "code": "public void setMaxExtractLength(int length) {\n        this.maxExtractLength = length;\n    }", "comment": " Sets the maximum number of characters to extract from binaries.", "issueId": "JCR-2506", "issueStringList": ["Stop text extraction when the maxFieldLength limit is reached", "When indexing large documents the text extraction often takes quite a while and uses lots of memory even if only the first maxFieldLength (by default 10000) tokens are used.", "I'd like to add a maxExtractLength parameter that can be used to set the maximum number of characters to extract from a binary.", "The default value of this parameter could be something like ten times the maxFieldLength setting.", "I implemented such a maxExtractLength parameter in revision 915356."], "SplitGT": [" Sets the maximum number of characters to extract from binaries."], "issueString": "Stop text extraction when the maxFieldLength limit is reached\nWhen indexing large documents the text extraction often takes quite a while and uses lots of memory even if only the first maxFieldLength (by default 10000) tokens are used. I'd like to add a maxExtractLength parameter that can be used to set the maximum number of characters to extract from a binary. The default value of this parameter could be something like ten times the maxFieldLength setting.\nI implemented such a maxExtractLength parameter in revision 915356.\n"}
