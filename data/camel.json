{"GlobalId": 1, "code": "public void setPredicateBean(final Predicate predicateBean) {\n        this.predicateBean = predicateBean;\n    }", "comment": " When sending messages to the control channel without using a DynamicRouterControlMessage, specify the Predicate by using this URI param.", "commitId": "55addd015d17278e9133a9cc3ec628f4299c7b34", "issueId": "CAMEL-17500", "issueString": "Make dynamic router eip component subscription easier\n{*}User Story{*}:\r\n\r\nAs a user of the Dynamic Router EIP component, I want to be able to subscribe with URL parameters so that I am not required to create a control message POJO to send as the message body.\r\n\r\n{*}Description / Explanation{*}:\r\n\r\nWhile a control channel POJO gives full control over the subscription or unsubscription, it would be more convenient to be able to send these messages from a routing participant by using URL parameters.\u00a0 Creating the control channel message for subscription looks like this:\r\n{code:java}\r\nDynamicRouterControlMessage billingSubMsg = new SubscribeMessageBuilder()\r\n                .id(\"billingSubscription\")\r\n                .channel(\"billing\")\r\n                .priority(10)\r\n                .endpointUri(myBillingNotificationUri)\r\n                .predicate(new SomeBillingPredicate())\r\n                .build(); {code}\r\nThen this is sent to the dynamic router control channel by:\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control\", billingSubMsg);{code}\r\nThe above could be simplified and combined by using the URI to specify the message:\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control/subscribe/billing?subscriptionId=billingSubscription&endpointUri=jms:billing&priority=10&predicate=${bodyAs(String)} regex '^\\\\d*[02468]$'\");{code}\r\nAlternatives can include:\r\n * Creating a {{Predicate}} as a bean, and referencing that bean as the {{predicate}}\r\n * Instantiating a {{Predicate}} and sending that predicate as the message body\r\n * Omitting the {{subscriptionId}} parameter, so that a subscription ID is generated and returned\r\n\r\nSimilarly, unsubscribing can be achieved by:\r\n\r\n\u00a0\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control/unsubscribe/billing?subscriptionId=billingSubscription);{code}\r\n\u00a0\r\n\r\n{*}Acceptance Criteria{*}:\r\n # Subscribing with all URI params:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component\r\n ** when: Routing participant sends empty message body to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\" and all other params\r\n ** then: Routing participant is subscribed with all supplied values\r\n # Unsubscribing:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, and routing participant has a valid subscription ID and channel name\r\n ** when: Routing participant sends empty message body to the dynamic router with the subscription URI beginning with \"dynamic-router:control/unsubscribe/\\{channel name}\" and the subscription ID\r\n ** then: Routing participant is unsubscribed for that channel and that subscription ID\r\n # Subscribing with URI params and Predicate bean:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, and a Predicate bean has been registered in the registry\r\n ** when: Routing participant sends an empty message to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\", the predicate parameter referencing the predicate bean, and all other params\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Subscribing with URI params and Predicate as message body:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component and a Predicate has been instantiated\r\n ** when: Routing participant sends an empty message to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\", and all other params, and the predicate instance is set as the message body\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Subscribing with control message POJO operates without change:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component and a control message POJO has been instantiated\r\n ** when: Routing participant sends subscribe POJO as message body to the control channel\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Unsubscribing with control message POJO operates without change:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, routing participant has a valid subscription ID and channel name,\u00a0 and a control message POJO for unsubscribing has been instantiated\r\n ** when: Routing participant sends unsubscribe POJO as message body to the control channel\r\n ** then:\u00a0Routing participant is unsubscribed for that channel and that subscription ID\r\n # Provide a mode to allow routing to all matching participants\r\n ** given: multiple subscribers with at least some overlapping filter predicates\r\n ** when: incoming messages match multiple recipients' filters\r\n ** then: all matching recipients receive a copy of the message\nFix up camel-spring-boot-examples caused by API changes here\r\nhttps://github.com/apache/camel-spring-boot-examples/commit/90e1c2aedda0fabced86e04ab9e622ee0628beca\n"}
{"GlobalId": 2, "code": "public void setSharedEntityManager(boolean sharedEntityManager) {\n        this.sharedEntityManager = sharedEntityManager;\n    }", "comment": " Whether to use Spring's SharedEntityManager for the consumer/producer.", "commitId": "3a98dd9d79aab778276ca96969599c49be82ec17", "issueId": "CAMEL-8054", "issueString": "Use SharedEntityManager to reduce connections\nWhen using JpaTransactionManager it \"Binds a JPA EntityManager from the specified factory to the thread\". Meaning that on top of the EntityManager created for each JpaConsumer, each time it creates a new EntityManager.\n\nNew property:\n*sharedEntityManager* - whether to use spring's SharedEntityManager for the consumer/producer. Sets joinTransaction=false\n\nAlso added as a property to the JpaComponent.\nI think we have improved/refactored camel-jpa for camel 2.14 or 2.15 to fix this.\n\nFrom the git log its CAMEL-7364\nThe improvements made in CAMEL-7364 are more around reusing a passed in EntityManager for JpaMessageIdRepository / JpaProducer - that refactoring didn't really affect the consumer.\n\nThis change is really focused around the use case of a jpa consumer and the JpaTransactionManager (if using a JtaTransactionManager it may have an affect, depending on whether it's using CMP or not.\n\nThe first patch I submitted had a few bugs, attached (CAMEL-8054-sharedEntityManager-2.13.patch) is the complete patch for 2.13, including a unit test.\nI'll do another patch for 2.14.\npatch for 2.14\nThanks for the patch. \n"}
{"GlobalId": 4, "code": "public static void pauseConsumers(final Queue<Consumer<byte[]>> consumers) {\n        consumers.forEach(Consumer::pause);\n    }", "comment": " Pauses the Pulsar consumers. Once paused, a Pulsar consumer does not request any more messages from the broker.", "commitId": "b5aa05313c6997b457fdc4c6e8375b4279161133", "issueId": "CAMEL-17551", "issueString": "camel-pulsar: Pause Pulsar consumers when a Pulsar route is suspended\n*Proposed change*\r\n\r\nWhen a Pulsar route is suspended/resumed, the route's PulsarConsumer should pause() and resume() its Pulsar consumers.\r\n\r\n*Background*\r\n\r\nCamel's PulsarConsumer is not currently suspendable. When `suspend()` is called on a Pulsar endpoint/route, the route and its PulsarConsumer are stopped instead, which in the current implementation will stop+close the underlying Pulsar consumers.\r\n\r\nAs a result, in-flight exchanges cannot complete because the Pulsar consumers can't ack messages when in a closed state.\u00a0\r\n\r\nPulsar consumers can be paused and resumed instead. A paused Pulsar consumer does not request any more messages from the broker, but it can still communicate with the broker, for example to ack messages it's already received. (However, after calling .pause() on a Pulsar consumer, it will finish processing any messages that were buffered in its receiver queue \u2013 up to `receiverQueueSize` # of messages).\u00a0\nThanks for reporting and the PR\n"}
{"GlobalId": 5, "code": "public static InputStream toInputStream(File file, String charset) throws IOException {\n        if (charset != null) {\n            return new EncodingInputStream(file, charset);\n        } else {\n            return toInputStream(file);\n        }\n    }", "comment": " Converts the given File with the given charset to InputStream with the JVM default charset", "commitId": "8fa8bc992a2d10a2efba7428da87cd79b7e08cd8", "issueId": "CAMEL-12769", "issueString": "Combination of File consumer with charset and Split DSL with XPath doesn't parse XML correctly\nThis route:\r\n{code:java}\r\nfrom(\"file:/...?charset=iso-8859-1&&include=.*\\.xml\")\r\n    .split(xpath(\"/foo/bar\"))\r\n        ...\r\n{code}\r\ndoes not read and split XML like the following with the correct encoding:\r\n{code:xml}\r\n<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\r\n<foo>\r\n\t<bar>abc</bar>\r\n\t<bar>xyz</bar>\r\n\t<bar>\u00e5\u00e4\u00f6</bar>\r\n</root>\r\n{code}\r\nThe root cause is due to the spec of {{IOConverter.toInputStream(File, String)}}:\r\n [https://github.com/apache/camel/blob/camel-2.22.1/camel-core/src/main/java/org/apache/camel/converter/IOConverter.java#L84-L119]\r\n which was clarified at CAMEL-8346 and CAMEL-8356.\r\n\r\nThis method converts a {{File}} with a charset to an {{InputStream}} with the *JVM default charset* encoding whatever the format of the file is. However, in turn [XmlConverter.toDOMDocument(...)|https://github.com/apache/camel/blob/camel-2.22.1/camel-core/src/main/java/org/apache/camel/converter/jaxp/XmlConverter.java#L870-L872] uses {{DocumentBuilder}} to convert the input stream to a DOM {{Document}} and {{DocumentBuilder}} is aware of the XML declaration:\r\n{code:xml}\r\n<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\r\n{code}\r\nto detect the file encoding, and there is a mismatch between the actual encoding of the input stream (JVM default) and the encoding declared in XML.\nThanks for reporting and the PR\n"}
{"GlobalId": 9, "code": "public void setSkipFirst(Boolean skipFirst) {\n        this.skipFirst = skipFirst;\n    }", "comment": " To skip the very first element", "commitId": "ff9bfd5e9077681966ffddea56bc93d9217207cd", "issueId": "CAMEL-9471", "issueString": "Tokenizer - Add option to skip first\nTo make it easy to skip first element when for example splitting a CSV file and using the tokenizer to split the file.\n\n\n"}
{"GlobalId": 10, "code": "public RestConfigurationProperties rest() {\n        return restConfigurationProperties;\n    }", "comment": " To configure Rest DSL", "commitId": "f2672e5d1728cef1f81bbcdeb35bc85957cdbf3c", "issueId": "CAMEL-13634", "issueString": "Camel main - Allow to configure rest dsl configuration\nSo you can configure in application.properties etc, some of the rest dsl configuration you would otherwise have to configure with restConfiguration() in the java dsl\n{code}\r\n# to configure Rest DSL (global and you need to add camel-undertow to the classpath)\r\ncamel.rest.component=undertow\r\ncamel.rest.port=8080\r\ncamel.rest.component-properties[host-options.buffer-size]=8192\r\n{code}\n"}
{"GlobalId": 11, "code": "public void setTransacted(boolean transacted) {\n        this.transacted = transacted;\n    }", "comment": " When <tt>false</tt> then all the good messages will commit, and the first failed message will rollback.", "commitId": "09e44c4c54a3050a2b221565d008358432bda527", "issueId": "CAMEL-4683", "issueString": "JpaConsumer - Add option to control if consumer should run in transacted mode and rollback all if one exchange failed\nSee nabble\nhttp://camel.465427.n5.nabble.com/Misleading-jmx-statistics-on-jpa-component-tp4960503p4960503.html\n\nWe should add option {{consumer.transacted}} to allow end users to control if they want the JpaConsumer to run in transacted mode, where by if one exchange failed to be processed, the entire batch is rolled back. If not, then all the good messages will be committed, and only the failed message will rollback.\n"}
{"GlobalId": 12, "code": "public Type disabled(boolean disabled) {\n        return disabled(disabled ? \"true\" : \"false\");\n    }", "comment": " Once an EIP has been disabled then it cannot be enabled later at runtime.", "commitId": "93985ea9e3530e20b2f6c581ccff32f5f418b9e0", "issueId": "CAMEL-18574", "issueString": "camel-core - Add disabled option to EIPs\nWhen working with EIPs you may want to temporary disable one or more EIPs. Today you have to comment out code, or remove the EIPs.\r\n\r\nBut we should add disabled = true|false so users can set it directly on the EIP and keep the code as-is. This will also help tooling where you can then easily [x] to disable something.\nOnce an EIP is disabled it cannot be enabled again at runtime. This is due to optimized routing engine to avoid the overhead of checking for enabled vs disabled. And since this feature is to make it quick to disable parts of routes during development or testing.\r\n\r\n\n"}
{"GlobalId": 13, "code": "public Type disabled() {\n        return disabled(\"true\");\n    }", "comment": " Once an EIP has been disabled then it cannot be enabled later at runtime.", "commitId": "93985ea9e3530e20b2f6c581ccff32f5f418b9e0", "issueId": "CAMEL-18574", "issueString": "camel-core - Add disabled option to EIPs\nWhen working with EIPs you may want to temporary disable one or more EIPs. Today you have to comment out code, or remove the EIPs.\r\n\r\nBut we should add disabled = true|false so users can set it directly on the EIP and keep the code as-is. This will also help tooling where you can then easily [x] to disable something.\nOnce an EIP is disabled it cannot be enabled again at runtime. This is due to optimized routing engine to avoid the overhead of checking for enabled vs disabled. And since this feature is to make it quick to disable parts of routes during development or testing.\r\n\r\n\n"}
{"GlobalId": 15, "code": "public String getSubscribeChannel() {\n        return subscribeChannel;\n    }", "comment": " When sending messages to the control channel without using a DynamicRouterControlMessage, specify the subscribe channel by using this URI path variable.", "commitId": "55addd015d17278e9133a9cc3ec628f4299c7b34", "issueId": "CAMEL-17500", "issueString": "Make dynamic router eip component subscription easier\n{*}User Story{*}:\r\n\r\nAs a user of the Dynamic Router EIP component, I want to be able to subscribe with URL parameters so that I am not required to create a control message POJO to send as the message body.\r\n\r\n{*}Description / Explanation{*}:\r\n\r\nWhile a control channel POJO gives full control over the subscription or unsubscription, it would be more convenient to be able to send these messages from a routing participant by using URL parameters.\u00a0 Creating the control channel message for subscription looks like this:\r\n{code:java}\r\nDynamicRouterControlMessage billingSubMsg = new SubscribeMessageBuilder()\r\n                .id(\"billingSubscription\")\r\n                .channel(\"billing\")\r\n                .priority(10)\r\n                .endpointUri(myBillingNotificationUri)\r\n                .predicate(new SomeBillingPredicate())\r\n                .build(); {code}\r\nThen this is sent to the dynamic router control channel by:\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control\", billingSubMsg);{code}\r\nThe above could be simplified and combined by using the URI to specify the message:\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control/subscribe/billing?subscriptionId=billingSubscription&endpointUri=jms:billing&priority=10&predicate=${bodyAs(String)} regex '^\\\\d*[02468]$'\");{code}\r\nAlternatives can include:\r\n * Creating a {{Predicate}} as a bean, and referencing that bean as the {{predicate}}\r\n * Instantiating a {{Predicate}} and sending that predicate as the message body\r\n * Omitting the {{subscriptionId}} parameter, so that a subscription ID is generated and returned\r\n\r\nSimilarly, unsubscribing can be achieved by:\r\n\r\n\u00a0\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control/unsubscribe/billing?subscriptionId=billingSubscription);{code}\r\n\u00a0\r\n\r\n{*}Acceptance Criteria{*}:\r\n # Subscribing with all URI params:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component\r\n ** when: Routing participant sends empty message body to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\" and all other params\r\n ** then: Routing participant is subscribed with all supplied values\r\n # Unsubscribing:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, and routing participant has a valid subscription ID and channel name\r\n ** when: Routing participant sends empty message body to the dynamic router with the subscription URI beginning with \"dynamic-router:control/unsubscribe/\\{channel name}\" and the subscription ID\r\n ** then: Routing participant is unsubscribed for that channel and that subscription ID\r\n # Subscribing with URI params and Predicate bean:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, and a Predicate bean has been registered in the registry\r\n ** when: Routing participant sends an empty message to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\", the predicate parameter referencing the predicate bean, and all other params\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Subscribing with URI params and Predicate as message body:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component and a Predicate has been instantiated\r\n ** when: Routing participant sends an empty message to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\", and all other params, and the predicate instance is set as the message body\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Subscribing with control message POJO operates without change:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component and a control message POJO has been instantiated\r\n ** when: Routing participant sends subscribe POJO as message body to the control channel\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Unsubscribing with control message POJO operates without change:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, routing participant has a valid subscription ID and channel name,\u00a0 and a control message POJO for unsubscribing has been instantiated\r\n ** when: Routing participant sends unsubscribe POJO as message body to the control channel\r\n ** then:\u00a0Routing participant is unsubscribed for that channel and that subscription ID\r\n # Provide a mode to allow routing to all matching participants\r\n ** given: multiple subscribers with at least some overlapping filter predicates\r\n ** when: incoming messages match multiple recipients' filters\r\n ** then: all matching recipients receive a copy of the message\nFix up camel-spring-boot-examples caused by API changes here\r\nhttps://github.com/apache/camel-spring-boot-examples/commit/90e1c2aedda0fabced86e04ab9e622ee0628beca\n"}
{"GlobalId": 16, "code": "public Integer getPriority() {\n        return priority;\n    }", "comment": " When sending messages to the control channel without using a DynamicRouterControlMessage, specify the subscription priority by using this URI param.", "commitId": "55addd015d17278e9133a9cc3ec628f4299c7b34", "issueId": "CAMEL-17500", "issueString": "Make dynamic router eip component subscription easier\n{*}User Story{*}:\r\n\r\nAs a user of the Dynamic Router EIP component, I want to be able to subscribe with URL parameters so that I am not required to create a control message POJO to send as the message body.\r\n\r\n{*}Description / Explanation{*}:\r\n\r\nWhile a control channel POJO gives full control over the subscription or unsubscription, it would be more convenient to be able to send these messages from a routing participant by using URL parameters.\u00a0 Creating the control channel message for subscription looks like this:\r\n{code:java}\r\nDynamicRouterControlMessage billingSubMsg = new SubscribeMessageBuilder()\r\n                .id(\"billingSubscription\")\r\n                .channel(\"billing\")\r\n                .priority(10)\r\n                .endpointUri(myBillingNotificationUri)\r\n                .predicate(new SomeBillingPredicate())\r\n                .build(); {code}\r\nThen this is sent to the dynamic router control channel by:\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control\", billingSubMsg);{code}\r\nThe above could be simplified and combined by using the URI to specify the message:\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control/subscribe/billing?subscriptionId=billingSubscription&endpointUri=jms:billing&priority=10&predicate=${bodyAs(String)} regex '^\\\\d*[02468]$'\");{code}\r\nAlternatives can include:\r\n * Creating a {{Predicate}} as a bean, and referencing that bean as the {{predicate}}\r\n * Instantiating a {{Predicate}} and sending that predicate as the message body\r\n * Omitting the {{subscriptionId}} parameter, so that a subscription ID is generated and returned\r\n\r\nSimilarly, unsubscribing can be achieved by:\r\n\r\n\u00a0\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control/unsubscribe/billing?subscriptionId=billingSubscription);{code}\r\n\u00a0\r\n\r\n{*}Acceptance Criteria{*}:\r\n # Subscribing with all URI params:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component\r\n ** when: Routing participant sends empty message body to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\" and all other params\r\n ** then: Routing participant is subscribed with all supplied values\r\n # Unsubscribing:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, and routing participant has a valid subscription ID and channel name\r\n ** when: Routing participant sends empty message body to the dynamic router with the subscription URI beginning with \"dynamic-router:control/unsubscribe/\\{channel name}\" and the subscription ID\r\n ** then: Routing participant is unsubscribed for that channel and that subscription ID\r\n # Subscribing with URI params and Predicate bean:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, and a Predicate bean has been registered in the registry\r\n ** when: Routing participant sends an empty message to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\", the predicate parameter referencing the predicate bean, and all other params\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Subscribing with URI params and Predicate as message body:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component and a Predicate has been instantiated\r\n ** when: Routing participant sends an empty message to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\", and all other params, and the predicate instance is set as the message body\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Subscribing with control message POJO operates without change:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component and a control message POJO has been instantiated\r\n ** when: Routing participant sends subscribe POJO as message body to the control channel\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Unsubscribing with control message POJO operates without change:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, routing participant has a valid subscription ID and channel name,\u00a0 and a control message POJO for unsubscribing has been instantiated\r\n ** when: Routing participant sends unsubscribe POJO as message body to the control channel\r\n ** then:\u00a0Routing participant is unsubscribed for that channel and that subscription ID\r\n # Provide a mode to allow routing to all matching participants\r\n ** given: multiple subscribers with at least some overlapping filter predicates\r\n ** when: incoming messages match multiple recipients' filters\r\n ** then: all matching recipients receive a copy of the message\nFix up camel-spring-boot-examples caused by API changes here\r\nhttps://github.com/apache/camel-spring-boot-examples/commit/90e1c2aedda0fabced86e04ab9e622ee0628beca\n"}
{"GlobalId": 17, "code": "public void setIncludeHeaders(String includeHeaders) {\n        this.includeHeaders = includeHeaders;\n    }", "comment": " A regex that defines which Camel headers are also included as MIME headers into the MIME multipart. This will only work if headersInline is set to true. Default is to include no headers", "commitId": "1044ce5fc39c4cb51d8465f8218bda466f2703a1", "issueId": "CAMEL-9544", "issueString": "Option to add headers to MIME-Multipart in DataFormat\nIn some cases it might be useful to add Camel headers to a MIME Multipart when the MIME headers are part of the message body.\n\nThe attached patch allows to transfer header (and attachment) information with protocols that support neither headers nor attachments (e.g. FTP).\n\nIt adds one additional parameter to the MIME-Multipart DataFormat:\n\nincludeHeaders: A regex that defines which Camel headers are also included as MIME headers into the MIME multipart. This will only work if headersInline is set to true.\nDefault is to include no Camel headers.\n\nThanks for the patch.\n\nDo you mind updating the docs at\nhttp://camel.apache.org/mime-multipart.html\nHi Claus,\n\nthanks for the support. I updated the docs together with Franz Forsthofer. We also fixed some errors like missing empty lines in the MIME examples and some wording Franz found not too comprehensible.\n\nBest regards\nStephan\n"}
{"GlobalId": 19, "code": "public void setAbsolutePosition(int absolutePosition) {\n        this.absolutePosition = absolutePosition;\n    }", "comment": " This is only available for Java DSL.", "commitId": "2cd9d9d09a613ae8739cdd2affbdad91fa7a2768", "issueId": "CAMEL-12640", "issueString": "tooling - Provide character position in validation result\ncurrently the line start and line end are provided but not the character position\nWe have the absolute charachter position. We can look at trying to have both\r\n * absolute character position\r\n * relative character position on the begin line\nWhen using XML DSL then mind that the positions are referring to the position of the end of the XML tag (for single XML tags), eg where you have <.../>. This is how the XML parser does it. If you have both a start and end xml tag, then the position refers to the start tag.\r\n\r\nThe absolute position is only available for Java DSL.\r\n\r\n\u00a0\n"}
{"GlobalId": 21, "code": "public Type disabled(String disabled) {\n        if (this instanceof OutputNode && getOutputs().isEmpty()) {\n            // set id on this\n            setDisabled(disabled);\n        } else {\n\n            // set it on last output as this is what the user means to do\n            // for Block(s) with non empty getOutputs() the id probably refers\n            // to the last definition in the current Block\n            List<ProcessorDefinition<?>> outputs = getOutputs();\n            if (!blocks.isEmpty()) {\n                if (blocks.getLast() instanceof ProcessorDefinition) {\n                    ProcessorDefinition<?> block = (ProcessorDefinition<?>) blocks.getLast();\n                    if (!block.getOutputs().isEmpty()) {\n                        outputs = block.getOutputs();\n                    }\n                }\n            }\n            if (!getOutputs().isEmpty()) {\n                outputs.get(outputs.size() - 1).setDisabled(disabled);\n            } else {\n                // the output could be empty\n                setDisabled(disabled);\n            }\n        }\n\n        return asType();\n    }", "comment": " Once an EIP has been disabled then it cannot be enabled later at runtime.", "commitId": "93985ea9e3530e20b2f6c581ccff32f5f418b9e0", "issueId": "CAMEL-18574", "issueString": "camel-core - Add disabled option to EIPs\nWhen working with EIPs you may want to temporary disable one or more EIPs. Today you have to comment out code, or remove the EIPs.\r\n\r\nBut we should add disabled = true|false so users can set it directly on the EIP and keep the code as-is. This will also help tooling where you can then easily [x] to disable something.\nOnce an EIP is disabled it cannot be enabled again at runtime. This is due to optimized routing engine to avoid the overhead of checking for enabled vs disabled. And since this feature is to make it quick to disable parts of routes during development or testing.\r\n\r\n\n"}
{"GlobalId": 24, "code": "public boolean isStopOnException() {\n        return stopOnException;\n    }", "comment": " Should the multicast processor stop processing further exchanges in case of an exception occurred?", "commitId": "78d454de8f47cbea9072fd7c9559ed6f3e22a359", "issueId": "CAMEL-1984", "issueString": "Multicast Processor - Add option to stop further processing in case of an exception occurred\nI think there is a old ticket about this as well, where XXX does not throw exception if an exception failed. But I cant find it. So creating a new ticket.\n\nWe should add this option to multicast (hence also splitter as its based on multicast)\n{code}\n    /**\n     * Will now stop further processing if an exception occurred during processing of an\n     * {@link org.apache.camel.Exchange} and the caused exception will be thrown.\n     * <p/>\n     * The default behavior is to <b>not</b> stop but continue processing till the end\n     *\n     * @return the builder\n     */\n    public MulticastDefinition stopOnException() {\n        setStopOnException(true);\n        return this;\n    }\n{code}\n\n\ntrunk: 810861.\n\nUpdated wiki as well.\n"}
{"GlobalId": 27, "code": "public void setBulkRequests(Integer bulkRequests) {\n\t\tthis.bulkRequests = bulkRequests;\n\t}", "comment": " Increasing this value may slightly improve file transfer speed but will increase memory usage.", "commitId": "f6586d0390598ee82567c5da4ca9b37ccc8bc381", "issueId": "CAMEL-9808", "issueString": "SFTP: Enable configuration of bulk requests\nJSch uses multiple requests to pull files from / push files to a SFTP server. The number of bulk requests can be configured via {{ChannelSftp#setBulkRequests(int)}}. The API documentation states that increasing this value may slightly improve file transfer speed at the cost of memory usage.\n\nThe configuration option should be made available in Camel.\n\nh4. Background\n\nI came across an issue with a specific SFTP server product. I tracked this issue down to the way bulk requests are sent to the SFTP server. To cut a long story short ([details here|https://sourceforge.net/p/jsch/mailman/jsch-users/thread/AM4PR10MB01646456AD2C94D911BDA763E1880%40AM4PR10MB0164.EURPRD10.PROD.OUTLOOK.COM/#msg34933773]) setting the number of bulk requests to 1 solves the problem, so it would be nice to have this option available via Camel.\nThanks I put some comments in the PR as there is some code formatting changes needed.\n\nYou can read about building with checkstyle here\nhttp://camel.apache.org/building\nThanks for the PR\nIs there any documentation that requires ti be updated and I am allowed to contribute to?\n"}
{"GlobalId": 28, "code": "public String getDestinationUri() {\n        return destinationUri;\n    }", "comment": " When sending messages to the control channel without using a DynamicRouterControlMessage, specify the destination URI by using this URI param.", "commitId": "55addd015d17278e9133a9cc3ec628f4299c7b34", "issueId": "CAMEL-17500", "issueString": "Make dynamic router eip component subscription easier\n{*}User Story{*}:\r\n\r\nAs a user of the Dynamic Router EIP component, I want to be able to subscribe with URL parameters so that I am not required to create a control message POJO to send as the message body.\r\n\r\n{*}Description / Explanation{*}:\r\n\r\nWhile a control channel POJO gives full control over the subscription or unsubscription, it would be more convenient to be able to send these messages from a routing participant by using URL parameters.\u00a0 Creating the control channel message for subscription looks like this:\r\n{code:java}\r\nDynamicRouterControlMessage billingSubMsg = new SubscribeMessageBuilder()\r\n                .id(\"billingSubscription\")\r\n                .channel(\"billing\")\r\n                .priority(10)\r\n                .endpointUri(myBillingNotificationUri)\r\n                .predicate(new SomeBillingPredicate())\r\n                .build(); {code}\r\nThen this is sent to the dynamic router control channel by:\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control\", billingSubMsg);{code}\r\nThe above could be simplified and combined by using the URI to specify the message:\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control/subscribe/billing?subscriptionId=billingSubscription&endpointUri=jms:billing&priority=10&predicate=${bodyAs(String)} regex '^\\\\d*[02468]$'\");{code}\r\nAlternatives can include:\r\n * Creating a {{Predicate}} as a bean, and referencing that bean as the {{predicate}}\r\n * Instantiating a {{Predicate}} and sending that predicate as the message body\r\n * Omitting the {{subscriptionId}} parameter, so that a subscription ID is generated and returned\r\n\r\nSimilarly, unsubscribing can be achieved by:\r\n\r\n\u00a0\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control/unsubscribe/billing?subscriptionId=billingSubscription);{code}\r\n\u00a0\r\n\r\n{*}Acceptance Criteria{*}:\r\n # Subscribing with all URI params:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component\r\n ** when: Routing participant sends empty message body to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\" and all other params\r\n ** then: Routing participant is subscribed with all supplied values\r\n # Unsubscribing:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, and routing participant has a valid subscription ID and channel name\r\n ** when: Routing participant sends empty message body to the dynamic router with the subscription URI beginning with \"dynamic-router:control/unsubscribe/\\{channel name}\" and the subscription ID\r\n ** then: Routing participant is unsubscribed for that channel and that subscription ID\r\n # Subscribing with URI params and Predicate bean:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, and a Predicate bean has been registered in the registry\r\n ** when: Routing participant sends an empty message to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\", the predicate parameter referencing the predicate bean, and all other params\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Subscribing with URI params and Predicate as message body:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component and a Predicate has been instantiated\r\n ** when: Routing participant sends an empty message to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\", and all other params, and the predicate instance is set as the message body\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Subscribing with control message POJO operates without change:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component and a control message POJO has been instantiated\r\n ** when: Routing participant sends subscribe POJO as message body to the control channel\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Unsubscribing with control message POJO operates without change:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, routing participant has a valid subscription ID and channel name,\u00a0 and a control message POJO for unsubscribing has been instantiated\r\n ** when: Routing participant sends unsubscribe POJO as message body to the control channel\r\n ** then:\u00a0Routing participant is unsubscribed for that channel and that subscription ID\r\n # Provide a mode to allow routing to all matching participants\r\n ** given: multiple subscribers with at least some overlapping filter predicates\r\n ** when: incoming messages match multiple recipients' filters\r\n ** then: all matching recipients receive a copy of the message\nFix up camel-spring-boot-examples caused by API changes here\r\nhttps://github.com/apache/camel-spring-boot-examples/commit/90e1c2aedda0fabced86e04ab9e622ee0628beca\n"}
{"GlobalId": 30, "code": "public void setMaxStoreSize(long maxStoreSize) {\n        this.maxStoreSize = maxStoreSize;\n    }", "comment": " The default is 1mb.", "commitId": "09151f2a765d0e88ab5ded46661d76b113f4f4da", "issueId": "CAMEL-1099", "issueString": "File consumer should keep track of processed files\nSee thread: http://www.nabble.com/Deprecation-of-file-consumer-timestamp-td20566034s22882.html\n\nWill be following Gert's suggestion of multiple implementations for the storage mechanism so many use cases can be covered:\n- an in-memory store for testing purposes\n- a file-based implementation for basic production environments\n- a database- or ldap-backed implementation for clustered environments, where a file can arrive through multiple directories\n\nI got a bit deep into the code today in the FileConsumer and have added options for *idempotent* so you can keep track of already consumed files.\n\nSee my new post on the nabble forum with this idea.\n\nJon do you mind review the commited source code on trunk. Sorry for invading this ticket, but the re factor of the file consumer needed to be done in one go as to have most unit test still passing. The commits will be on CAMEL-1112\nTo review:\n- I have set the default cache size of the memory to 1000, is this a good default value?\n- FileConsumer code\n- file.getName is that a sufficient key for idempotent check (should we use absolute file name instead?)\n- Is the header keys for index/total a good key name?\n- Should idempotent be enabled by default?\n\nNotice for unit tests that want to consume files but not delete: noop=true&idempotent=true will be as before, only consuming the file ones and not delete the source files.\nMessageIdRepository should be renamed and moved to org.apache.camel.spi\nMessageIdRepository -> IdempotentRepository\n\nSee nabble post with James suggestion for this.\n\n\nJames had a good idea about the interface methods\n\nHow about following the Set naming convention?\n\nboolean add(element) // Returns true if this set did not already\ncontain the specified element.\n\nboolean contains(element) // for peek\nBTW: I am currently working on moving the idempotent repository to the spi package.\n\nShould we support generic, like the Set contract?\n\nShould it be:\npublic interface IdempotentRepository<E>\nOr without the <E> and using Object as the key type?\n\nI currently have the generics version\n\n\nI know we've been removing generics all over the place in Camel lately... I like it in this case though. +1 to your current code.\n\nClaus, you've pretty much completed this task so I'm assigning it to you so you get the credit :)\n+1\nJon, let's have joint credit, we are a team after all ;)\n\nI am wondering if we / I should dig deeper to do something with the MemoryIdempotentRepository as it states that you should be careful with the cache Map to avoid memory leeks.\n\nI was wondering if we could get the Service interface with start/stop to eg. clear the cache on stop. But I guess the callback of Service is not invoked on the idempotent node. Well something to think about.\n\nAny thoughts?\nMaybe noop=true should also make idempotent=true. It makes sense *not* to process the same file over and over again.\nD:\\project\\camel>svn commit --message \"CAMEL-1099: Introduced IdempotentRepository in the spi package.\"\nSending        camel-core\\src\\main\\java\\org\\apache\\camel\\component\\file\\FileComponent.java\nSending        camel-core\\src\\main\\java\\org\\apache\\camel\\component\\file\\FileConsumer.java\nSending        camel-core\\src\\main\\java\\org\\apache\\camel\\component\\file\\FileEndpoint.java\nSending        camel-core\\src\\main\\java\\org\\apache\\camel\\model\\IdempotentConsumerType.java\nSending        camel-core\\src\\main\\java\\org\\apache\\camel\\model\\ProcessorType.java\nSending        camel-core\\src\\main\\java\\org\\apache\\camel\\processor\\idempotent\\IdempotentConsumer.java\nAdding         camel-core\\src\\main\\java\\org\\apache\\camel\\processor\\idempotent\\MemoryIdempotentRepository.java\nDeleting       camel-core\\src\\main\\java\\org\\apache\\camel\\processor\\idempotent\\MemoryMessageIdRepository.java\nDeleting       camel-core\\src\\main\\java\\org\\apache\\camel\\processor\\idempotent\\MessageIdRepository.java\nAdding         camel-core\\src\\main\\java\\org\\apache\\camel\\spi\\IdempotentRepository.java\nSending        camel-core\\src\\test\\java\\org\\apache\\camel\\builder\\RouteBuilderTest.java\nSending        camel-core\\src\\test\\java\\org\\apache\\camel\\component\\file\\FileConsumerIdempotentRefTest.java\nSending        camel-core\\src\\test\\java\\org\\apache\\camel\\processor\\IdempotentConsumerTest.java\nSending        components\\camel-jpa\\src\\main\\java\\org\\apache\\camel\\processor\\idempotent\\jpa\\JpaMessageIdRepository.java\nSending        components\\camel-spring\\src\\test\\java\\org\\apache\\camel\\component\\test\\TestEndpointTest.java\nSending        components\\camel-spring\\src\\test\\resources\\org\\apache\\camel\\component\\test\\TestEndpointTest-context.xml\nTransmitting file data ..............\nCommitted revision 722088.\n- Refactor idempotent interface to spi package *DONE*\n- Wiki sample how to use the Jpa store provided by camel-jpa *DONE*\n- Add a file based repository *DONE*\n- Wiki sample how to use the File store *DONE*\nClaus, I wouldn't spend too much time on the MemoryIdempotentRepository, I don't think many users would want to use this in a production scenario (the file and jpa options are much more attractive). The best we can do in this case is recommend the LRU cache option so the memory doesn't get too out of hand I guess.\nJon, others?\n\nAny good ideas of the file based repository?\n\nI am wondering if we should\n- have the LRUCache as a 1st level cache, and have write through to the file store when adding, using append\n- load the filestore on startup\n- configurable filename and folder\n- use camel file component to read/write (configuration could then be a file endpoint = \"file://data/idempotentrepository.txt?append=true&autoCreate=true\")\nSo when there is a miss on the LRUCache, the file repository would be queried (and this is the only case that it would queried)? I'm just wondering what kind of format we want for this kinda file... having it appended to with every add seems to imply that it would be a big list that we'd have to scroll through (very slow). Maybe I'm missing an obvious solution, it is early here :)\nWill think about this some more when I get into the office. I bet there are some very cool file based index things in KahaDB though http://svn.apache.org/repos/asf/activemq/trunk/kahadb/\nWell the file list will be loaded at startup and then only used for write when there is a cache *miss*, so there would not be a performance hit at runtime.\n\nI think it's overkill to use some kind of 3rd party lib\n\nupdated: a miss of course ;)\nMakes sense (now that I'm fully caffeinated :) )\n"}
{"GlobalId": 33, "code": "public void setLimit(int limit) {\n        this.limit = limit;\n    }", "comment": " The limit is by default 3.", "commitId": "1fad136fe822819607c0de79df61b3c9ace4f8a5", "issueId": "CAMEL-3125", "issueString": "When the fetching of a feed causes, polling continues endlessly, flooding the logs and creating unwanted network load.\nThe problem is with the default implementation of org.apache.camel.spi.PollingConsumerPollStrategy: org.apache.camel.impl.DefaultPollingConsumerPollStrategy\nWhen an error occurs rollback() is called, and this method just logs the error and returns false, which means the polling will not be retried for that execution of the run() method. \nThis means it will be retried after the delay.\n\nI created an implementation that suspends the Consumer, which seems like acceptable default behavior. It also allows for extension and adding some hooks for custom stuff. In order for that to be useful it should be made easier to set your own PollingConsumerPollStrategy implementation.\n\n\nThis is my class that solves the problem\nSo you impl will invoke onError the first 2 times, and then the 3rd time it invokes onSuspend. Then when its in the future it will invoke onError.\nThe misses is never reset.\n\nAlso this is a stateful implementation which mean you should use a new instance on each different consumer.\n\ntrunk: 998065.\n\nThere is now a {{LimitedPollingConsumerPollStrategy}} which is stateful and supports multiple consumers, so you can use it for multiple routes.\nIt will reset if a consumer is being suspended, so when you manually start the consumer its been reset.\n\nThere is a limit option you can set, its by default 3.\n"}
{"GlobalId": 34, "code": "public void setSharedEntityManager(boolean sharedEntityManager) {\n        this.sharedEntityManager = sharedEntityManager;\n    }", "comment": " Whether to use Spring's SharedEntityManager for the consumer/producer.", "commitId": "3a98dd9d79aab778276ca96969599c49be82ec17", "issueId": "CAMEL-8054", "issueString": "Use SharedEntityManager to reduce connections\nWhen using JpaTransactionManager it \"Binds a JPA EntityManager from the specified factory to the thread\". Meaning that on top of the EntityManager created for each JpaConsumer, each time it creates a new EntityManager.\n\nNew property:\n*sharedEntityManager* - whether to use spring's SharedEntityManager for the consumer/producer. Sets joinTransaction=false\n\nAlso added as a property to the JpaComponent.\nI think we have improved/refactored camel-jpa for camel 2.14 or 2.15 to fix this.\n\nFrom the git log its CAMEL-7364\nThe improvements made in CAMEL-7364 are more around reusing a passed in EntityManager for JpaMessageIdRepository / JpaProducer - that refactoring didn't really affect the consumer.\n\nThis change is really focused around the use case of a jpa consumer and the JpaTransactionManager (if using a JtaTransactionManager it may have an affect, depending on whether it's using CMP or not.\n\nThe first patch I submitted had a few bugs, attached (CAMEL-8054-sharedEntityManager-2.13.patch) is the complete patch for 2.13, including a unit test.\nI'll do another patch for 2.14.\npatch for 2.14\nThanks for the patch. \n"}
{"GlobalId": 36, "code": "public Predicate getPredicateBean() {\n        return predicateBean;\n    }", "comment": " When sending messages to the control channel without using a DynamicRouterControlMessage, specify the Predicate by using this URI param.", "commitId": "55addd015d17278e9133a9cc3ec628f4299c7b34", "issueId": "CAMEL-17500", "issueString": "Make dynamic router eip component subscription easier\n{*}User Story{*}:\r\n\r\nAs a user of the Dynamic Router EIP component, I want to be able to subscribe with URL parameters so that I am not required to create a control message POJO to send as the message body.\r\n\r\n{*}Description / Explanation{*}:\r\n\r\nWhile a control channel POJO gives full control over the subscription or unsubscription, it would be more convenient to be able to send these messages from a routing participant by using URL parameters.\u00a0 Creating the control channel message for subscription looks like this:\r\n{code:java}\r\nDynamicRouterControlMessage billingSubMsg = new SubscribeMessageBuilder()\r\n                .id(\"billingSubscription\")\r\n                .channel(\"billing\")\r\n                .priority(10)\r\n                .endpointUri(myBillingNotificationUri)\r\n                .predicate(new SomeBillingPredicate())\r\n                .build(); {code}\r\nThen this is sent to the dynamic router control channel by:\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control\", billingSubMsg);{code}\r\nThe above could be simplified and combined by using the URI to specify the message:\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control/subscribe/billing?subscriptionId=billingSubscription&endpointUri=jms:billing&priority=10&predicate=${bodyAs(String)} regex '^\\\\d*[02468]$'\");{code}\r\nAlternatives can include:\r\n * Creating a {{Predicate}} as a bean, and referencing that bean as the {{predicate}}\r\n * Instantiating a {{Predicate}} and sending that predicate as the message body\r\n * Omitting the {{subscriptionId}} parameter, so that a subscription ID is generated and returned\r\n\r\nSimilarly, unsubscribing can be achieved by:\r\n\r\n\u00a0\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control/unsubscribe/billing?subscriptionId=billingSubscription);{code}\r\n\u00a0\r\n\r\n{*}Acceptance Criteria{*}:\r\n # Subscribing with all URI params:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component\r\n ** when: Routing participant sends empty message body to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\" and all other params\r\n ** then: Routing participant is subscribed with all supplied values\r\n # Unsubscribing:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, and routing participant has a valid subscription ID and channel name\r\n ** when: Routing participant sends empty message body to the dynamic router with the subscription URI beginning with \"dynamic-router:control/unsubscribe/\\{channel name}\" and the subscription ID\r\n ** then: Routing participant is unsubscribed for that channel and that subscription ID\r\n # Subscribing with URI params and Predicate bean:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, and a Predicate bean has been registered in the registry\r\n ** when: Routing participant sends an empty message to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\", the predicate parameter referencing the predicate bean, and all other params\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Subscribing with URI params and Predicate as message body:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component and a Predicate has been instantiated\r\n ** when: Routing participant sends an empty message to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\", and all other params, and the predicate instance is set as the message body\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Subscribing with control message POJO operates without change:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component and a control message POJO has been instantiated\r\n ** when: Routing participant sends subscribe POJO as message body to the control channel\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Unsubscribing with control message POJO operates without change:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, routing participant has a valid subscription ID and channel name,\u00a0 and a control message POJO for unsubscribing has been instantiated\r\n ** when: Routing participant sends unsubscribe POJO as message body to the control channel\r\n ** then:\u00a0Routing participant is unsubscribed for that channel and that subscription ID\r\n # Provide a mode to allow routing to all matching participants\r\n ** given: multiple subscribers with at least some overlapping filter predicates\r\n ** when: incoming messages match multiple recipients' filters\r\n ** then: all matching recipients receive a copy of the message\nFix up camel-spring-boot-examples caused by API changes here\r\nhttps://github.com/apache/camel-spring-boot-examples/commit/90e1c2aedda0fabced86e04ab9e622ee0628beca\n"}
{"GlobalId": 37, "code": "public void setPkChunking(Boolean pkChunking) {\n        this.pkChunking = pkChunking;\n    }", "comment": " Bulk 2.0 API performs PK chunking automatically, if necessary.", "commitId": "7a92d98f705ecfd5a9ea2740d619da3cf67206b3", "issueId": "CAMEL-12808", "issueString": "Add support for PK Chunking in Salesforce Bulk API\nSalesforce supports chunking primary keys in queries for tables with a large number of records as described at [1]. This reduces the number of records returned in Batch results, by adding more batches to jobs. This helps reduce the amount of data that has to be buffered in the Salesforce component's Jetty client response buffer.\u00a0\r\n\r\n[1]\u00a0https://developer.salesforce.com/docs/atlas.en-us.api_asynch.meta/api_asynch/async_api_headers_enable_pk_chunking.htm\nSubmitted PR for this. Note that Bulk 2.0 API does PK chunking automatically, if necessary.\n"}
{"GlobalId": 39, "code": "public void setLinePosition(int linePosition) {\n        this.linePosition = linePosition;\n    }", "comment": " The relative position in the begin line number.", "commitId": "2cd9d9d09a613ae8739cdd2affbdad91fa7a2768", "issueId": "CAMEL-12640", "issueString": "tooling - Provide character position in validation result\ncurrently the line start and line end are provided but not the character position\nWe have the absolute charachter position. We can look at trying to have both\r\n * absolute character position\r\n * relative character position on the begin line\nWhen using XML DSL then mind that the positions are referring to the position of the end of the XML tag (for single XML tags), eg where you have <.../>. This is how the XML parser does it. If you have both a start and end xml tag, then the position refers to the start tag.\r\n\r\nThe absolute position is only available for Java DSL.\r\n\r\n\u00a0\n"}
{"GlobalId": 40, "code": "public void setExclusive(boolean exclusive) {\n        this.exclusive = exclusive;\n    }", "comment": " Exclusive queues may only be accessed by the current connection, and are deleted when that connection closes.", "commitId": "80d21843894c30fff68f48dab9e1c28d6b0ca544", "issueId": "CAMEL-10131", "issueString": "Add exclusive queues support to RabbitMQ component\n Exclusive queues are used by only one connection and the queue will be deleted when that connection closes. At the moment the rabbitmq component does not support exclusive queues. I believe that it is an important feature to have, especially when using fanout exchanges, since the generated queues will not autodelete when the client disconnects, leaving queues with no consumers behind, which require manual/scripted intervention.\n"}
{"GlobalId": 41, "code": "public void setExpressionLanguage(final String expressionLanguage) {\n        this.expressionLanguage = expressionLanguage;\n    }", "comment": " When sending messages to the control channel without using a DynamicRouterControlMessage, specify the expression language for creating the Predicate by using this URI param.", "commitId": "55addd015d17278e9133a9cc3ec628f4299c7b34", "issueId": "CAMEL-17500", "issueString": "Make dynamic router eip component subscription easier\n{*}User Story{*}:\r\n\r\nAs a user of the Dynamic Router EIP component, I want to be able to subscribe with URL parameters so that I am not required to create a control message POJO to send as the message body.\r\n\r\n{*}Description / Explanation{*}:\r\n\r\nWhile a control channel POJO gives full control over the subscription or unsubscription, it would be more convenient to be able to send these messages from a routing participant by using URL parameters.\u00a0 Creating the control channel message for subscription looks like this:\r\n{code:java}\r\nDynamicRouterControlMessage billingSubMsg = new SubscribeMessageBuilder()\r\n                .id(\"billingSubscription\")\r\n                .channel(\"billing\")\r\n                .priority(10)\r\n                .endpointUri(myBillingNotificationUri)\r\n                .predicate(new SomeBillingPredicate())\r\n                .build(); {code}\r\nThen this is sent to the dynamic router control channel by:\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control\", billingSubMsg);{code}\r\nThe above could be simplified and combined by using the URI to specify the message:\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control/subscribe/billing?subscriptionId=billingSubscription&endpointUri=jms:billing&priority=10&predicate=${bodyAs(String)} regex '^\\\\d*[02468]$'\");{code}\r\nAlternatives can include:\r\n * Creating a {{Predicate}} as a bean, and referencing that bean as the {{predicate}}\r\n * Instantiating a {{Predicate}} and sending that predicate as the message body\r\n * Omitting the {{subscriptionId}} parameter, so that a subscription ID is generated and returned\r\n\r\nSimilarly, unsubscribing can be achieved by:\r\n\r\n\u00a0\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control/unsubscribe/billing?subscriptionId=billingSubscription);{code}\r\n\u00a0\r\n\r\n{*}Acceptance Criteria{*}:\r\n # Subscribing with all URI params:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component\r\n ** when: Routing participant sends empty message body to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\" and all other params\r\n ** then: Routing participant is subscribed with all supplied values\r\n # Unsubscribing:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, and routing participant has a valid subscription ID and channel name\r\n ** when: Routing participant sends empty message body to the dynamic router with the subscription URI beginning with \"dynamic-router:control/unsubscribe/\\{channel name}\" and the subscription ID\r\n ** then: Routing participant is unsubscribed for that channel and that subscription ID\r\n # Subscribing with URI params and Predicate bean:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, and a Predicate bean has been registered in the registry\r\n ** when: Routing participant sends an empty message to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\", the predicate parameter referencing the predicate bean, and all other params\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Subscribing with URI params and Predicate as message body:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component and a Predicate has been instantiated\r\n ** when: Routing participant sends an empty message to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\", and all other params, and the predicate instance is set as the message body\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Subscribing with control message POJO operates without change:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component and a control message POJO has been instantiated\r\n ** when: Routing participant sends subscribe POJO as message body to the control channel\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Unsubscribing with control message POJO operates without change:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, routing participant has a valid subscription ID and channel name,\u00a0 and a control message POJO for unsubscribing has been instantiated\r\n ** when: Routing participant sends unsubscribe POJO as message body to the control channel\r\n ** then:\u00a0Routing participant is unsubscribed for that channel and that subscription ID\r\n # Provide a mode to allow routing to all matching participants\r\n ** given: multiple subscribers with at least some overlapping filter predicates\r\n ** when: incoming messages match multiple recipients' filters\r\n ** then: all matching recipients receive a copy of the message\nFix up camel-spring-boot-examples caused by API changes here\r\nhttps://github.com/apache/camel-spring-boot-examples/commit/90e1c2aedda0fabced86e04ab9e622ee0628beca\n"}
{"GlobalId": 44, "code": "public int getScrollKeepAliveMs() {\n        return scrollKeepAliveMs;\n    }", "comment": " Time in ms during which elasticsearch will keep search context alive", "commitId": "79b2a8872316823b05c9355f0a4dd0487b798846", "issueId": "CAMEL-13071", "issueString": "Elasticsearch rest component should support scroll api\nOn some projects we need to fetch all results from Elasticsearch.\r\n\r\nThis is currently quite difficult.\r\n\r\nHere is an example of usage that could be implemented:\r\n{code:java|title=ElasticsearchRouter.java|borderStyle=solid}\r\nfrom(\"direct:search\")\r\n  .to(\"elasticsearch-rest://elasticsearch?operation=Search&indexName=twitter&indexType=tweet&useScroll=true&scrollKeepAliveMs=30000\")\r\n  .split()\r\n  .body()\r\n  .streaming()\r\n  .to(\"mock:output\")\r\n  .end();\r\n{code}\r\nTwo new parameters could be used:\r\n * useScroll: enable scroll usage\r\n * scrollKeepAliveMs: time in ms during which elasticsearch will keep search context alive\n"}
{"GlobalId": 45, "code": "public void setAccessToken(String accessToken) {\n        this.accessToken = accessToken;\n    }", "comment": " The access token granted by a merchant to another in order to process transactions on their behalf.", "commitId": "35341491fc7ca26f552d1c6c4900f437f7e2079e", "issueId": "CAMEL-12137", "issueString": "Add Support for Braintree Auth\nThe Braintree Component currently only supports configuration using the Braintree provided merchantId, environment, public key and private key.\r\n\r\nBraintree now also supports configuration using an Access Token, which is granted by a merchant to another merchant so that they can process transactions on their behalf. More information can be found here: https://developers.braintreepayments.com/guides/braintree-auth/overview\r\n\r\nThe Braintree Component should support configuration using either method.\n"}
{"GlobalId": 48, "code": "public boolean isTrimRecordOnUnmarshal() {\r\n        return trimRecordOnUnmarshal;\r\n    }", "comment": " Flag indicating whether the fixed length record should be trimmed", "commitId": "887c6ab4f409ce9c2d1e061afba588a696e9028b", "issueId": "CAMEL-3562", "issueString": "BindyFixedLengthDataFormat does a trim on Fixed Length record\nBindyFixedLengthDataFormat does a trim on Fixed Length record, although Fixed Length recordare strictly positional in nature and may contain lot of fillers with empty spaces, doing a trim causes Bindy to fail the message length validation and exception is thrown on message length \n\n// Read the line \nString line = scanner.nextLine().trim(); \n\nShould be changed to \n\n// Read the line \nString line = scanner.nextLine(); \n\nOr a conditional option should be provided in FixedLengthRecord annotation whether or not to trim the entire record\nPlease find attached a patch that fixes this issue by adding another option to the FIxedLengthRecord annotation called trimRecordOnUnmarshal with default value set to true. The user can then alter this behavior to achieve the effect needed.\n\nUnit tests are provided...\n\nCheers,\n\nAshwin...\nI think the option {{trimRecordOnUnmarshal}} is a bit to verbose. Is it possible to name it {{trim}}.\n\nI think frankly it should not trim by default (although it does this now).\nThen you get the fixed length as is, which you feels more natural fixed lengtth formats.\n\nAny thoughts?\n\n\n\nCommitted patch to trunk under revisions  r1061411, r1061413, r1061420,  r1061425,  r1061426.\n\n\nHi Claus,\n\nI was a little conflicted about it. I wanted to use something that would indicate that trimming was only applicable to the Unmarshal phase.\n\nI will also change the default as you suggest. I guess given that it is a different camel version, so long as the documentation is good it should suffice. I will make both the changes you suggest.\n\nCheers,\n\nAshwin...\nHi Claus,\n\nI have added an updated bindy patch that takes care of both the changes you recommended. I have also updated the camel unit tests to works appropriately.\n\nI will update the wiki documentation to reflect the change (documentation still work in progress) following the commit to the trunk.\n\nCheers,\n\nAshwin...\nUpdated behavior committed to the camel trunk as r1061479. \n"}
{"GlobalId": 50, "code": "public void setApiContextRouteId(String apiContextRouteId) {\n        this.apiContextRouteId = apiContextRouteId;\n    }", "comment": " The route will by default use an auto assigned route id.", "commitId": "9ff11b57f5f5ea8efee195680617930d67d2c8d9", "issueId": "CAMEL-9251", "issueString": "rest-dsl - Allow to configure api-doc route id\nYou may want to be able to specify a route id as by default its an auto assigned route id.\n\nThere is a new apiContextRouteId option you can use to configure this.\n"}
{"GlobalId": 51, "code": "public void setPredicate(final String predicate) {\n        this.predicate = predicate;\n    }", "comment": " When sending messages to the control channel without using a DynamicRouterControlMessage, specify the Predicate by using this URI param.", "commitId": "55addd015d17278e9133a9cc3ec628f4299c7b34", "issueId": "CAMEL-17500", "issueString": "Make dynamic router eip component subscription easier\n{*}User Story{*}:\r\n\r\nAs a user of the Dynamic Router EIP component, I want to be able to subscribe with URL parameters so that I am not required to create a control message POJO to send as the message body.\r\n\r\n{*}Description / Explanation{*}:\r\n\r\nWhile a control channel POJO gives full control over the subscription or unsubscription, it would be more convenient to be able to send these messages from a routing participant by using URL parameters.\u00a0 Creating the control channel message for subscription looks like this:\r\n{code:java}\r\nDynamicRouterControlMessage billingSubMsg = new SubscribeMessageBuilder()\r\n                .id(\"billingSubscription\")\r\n                .channel(\"billing\")\r\n                .priority(10)\r\n                .endpointUri(myBillingNotificationUri)\r\n                .predicate(new SomeBillingPredicate())\r\n                .build(); {code}\r\nThen this is sent to the dynamic router control channel by:\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control\", billingSubMsg);{code}\r\nThe above could be simplified and combined by using the URI to specify the message:\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control/subscribe/billing?subscriptionId=billingSubscription&endpointUri=jms:billing&priority=10&predicate=${bodyAs(String)} regex '^\\\\d*[02468]$'\");{code}\r\nAlternatives can include:\r\n * Creating a {{Predicate}} as a bean, and referencing that bean as the {{predicate}}\r\n * Instantiating a {{Predicate}} and sending that predicate as the message body\r\n * Omitting the {{subscriptionId}} parameter, so that a subscription ID is generated and returned\r\n\r\nSimilarly, unsubscribing can be achieved by:\r\n\r\n\u00a0\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control/unsubscribe/billing?subscriptionId=billingSubscription);{code}\r\n\u00a0\r\n\r\n{*}Acceptance Criteria{*}:\r\n # Subscribing with all URI params:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component\r\n ** when: Routing participant sends empty message body to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\" and all other params\r\n ** then: Routing participant is subscribed with all supplied values\r\n # Unsubscribing:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, and routing participant has a valid subscription ID and channel name\r\n ** when: Routing participant sends empty message body to the dynamic router with the subscription URI beginning with \"dynamic-router:control/unsubscribe/\\{channel name}\" and the subscription ID\r\n ** then: Routing participant is unsubscribed for that channel and that subscription ID\r\n # Subscribing with URI params and Predicate bean:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, and a Predicate bean has been registered in the registry\r\n ** when: Routing participant sends an empty message to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\", the predicate parameter referencing the predicate bean, and all other params\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Subscribing with URI params and Predicate as message body:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component and a Predicate has been instantiated\r\n ** when: Routing participant sends an empty message to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\", and all other params, and the predicate instance is set as the message body\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Subscribing with control message POJO operates without change:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component and a control message POJO has been instantiated\r\n ** when: Routing participant sends subscribe POJO as message body to the control channel\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Unsubscribing with control message POJO operates without change:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, routing participant has a valid subscription ID and channel name,\u00a0 and a control message POJO for unsubscribing has been instantiated\r\n ** when: Routing participant sends unsubscribe POJO as message body to the control channel\r\n ** then:\u00a0Routing participant is unsubscribed for that channel and that subscription ID\r\n # Provide a mode to allow routing to all matching participants\r\n ** given: multiple subscribers with at least some overlapping filter predicates\r\n ** when: incoming messages match multiple recipients' filters\r\n ** then: all matching recipients receive a copy of the message\nFix up camel-spring-boot-examples caused by API changes here\r\nhttps://github.com/apache/camel-spring-boot-examples/commit/90e1c2aedda0fabced86e04ab9e622ee0628beca\n"}
{"GlobalId": 53, "code": "public String getPredicate() {\n        return predicate;\n    }", "comment": " When sending messages to the control channel without using a DynamicRouterControlMessage, specify the Predicate by using this URI param.", "commitId": "55addd015d17278e9133a9cc3ec628f4299c7b34", "issueId": "CAMEL-17500", "issueString": "Make dynamic router eip component subscription easier\n{*}User Story{*}:\r\n\r\nAs a user of the Dynamic Router EIP component, I want to be able to subscribe with URL parameters so that I am not required to create a control message POJO to send as the message body.\r\n\r\n{*}Description / Explanation{*}:\r\n\r\nWhile a control channel POJO gives full control over the subscription or unsubscription, it would be more convenient to be able to send these messages from a routing participant by using URL parameters.\u00a0 Creating the control channel message for subscription looks like this:\r\n{code:java}\r\nDynamicRouterControlMessage billingSubMsg = new SubscribeMessageBuilder()\r\n                .id(\"billingSubscription\")\r\n                .channel(\"billing\")\r\n                .priority(10)\r\n                .endpointUri(myBillingNotificationUri)\r\n                .predicate(new SomeBillingPredicate())\r\n                .build(); {code}\r\nThen this is sent to the dynamic router control channel by:\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control\", billingSubMsg);{code}\r\nThe above could be simplified and combined by using the URI to specify the message:\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control/subscribe/billing?subscriptionId=billingSubscription&endpointUri=jms:billing&priority=10&predicate=${bodyAs(String)} regex '^\\\\d*[02468]$'\");{code}\r\nAlternatives can include:\r\n * Creating a {{Predicate}} as a bean, and referencing that bean as the {{predicate}}\r\n * Instantiating a {{Predicate}} and sending that predicate as the message body\r\n * Omitting the {{subscriptionId}} parameter, so that a subscription ID is generated and returned\r\n\r\nSimilarly, unsubscribing can be achieved by:\r\n\r\n\u00a0\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control/unsubscribe/billing?subscriptionId=billingSubscription);{code}\r\n\u00a0\r\n\r\n{*}Acceptance Criteria{*}:\r\n # Subscribing with all URI params:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component\r\n ** when: Routing participant sends empty message body to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\" and all other params\r\n ** then: Routing participant is subscribed with all supplied values\r\n # Unsubscribing:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, and routing participant has a valid subscription ID and channel name\r\n ** when: Routing participant sends empty message body to the dynamic router with the subscription URI beginning with \"dynamic-router:control/unsubscribe/\\{channel name}\" and the subscription ID\r\n ** then: Routing participant is unsubscribed for that channel and that subscription ID\r\n # Subscribing with URI params and Predicate bean:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, and a Predicate bean has been registered in the registry\r\n ** when: Routing participant sends an empty message to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\", the predicate parameter referencing the predicate bean, and all other params\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Subscribing with URI params and Predicate as message body:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component and a Predicate has been instantiated\r\n ** when: Routing participant sends an empty message to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\", and all other params, and the predicate instance is set as the message body\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Subscribing with control message POJO operates without change:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component and a control message POJO has been instantiated\r\n ** when: Routing participant sends subscribe POJO as message body to the control channel\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Unsubscribing with control message POJO operates without change:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, routing participant has a valid subscription ID and channel name,\u00a0 and a control message POJO for unsubscribing has been instantiated\r\n ** when: Routing participant sends unsubscribe POJO as message body to the control channel\r\n ** then:\u00a0Routing participant is unsubscribed for that channel and that subscription ID\r\n # Provide a mode to allow routing to all matching participants\r\n ** given: multiple subscribers with at least some overlapping filter predicates\r\n ** when: incoming messages match multiple recipients' filters\r\n ** then: all matching recipients receive a copy of the message\nFix up camel-spring-boot-examples caused by API changes here\r\nhttps://github.com/apache/camel-spring-boot-examples/commit/90e1c2aedda0fabced86e04ab9e622ee0628beca\n"}
{"GlobalId": 55, "code": "public void setSubscribeChannel(final String subscribeChannel) {\n        this.subscribeChannel = subscribeChannel;\n    }", "comment": " When sending messages to the control channel without using a DynamicRouterControlMessage, specify the subscribe channel by using this URI path variable.", "commitId": "55addd015d17278e9133a9cc3ec628f4299c7b34", "issueId": "CAMEL-17500", "issueString": "Make dynamic router eip component subscription easier\n{*}User Story{*}:\r\n\r\nAs a user of the Dynamic Router EIP component, I want to be able to subscribe with URL parameters so that I am not required to create a control message POJO to send as the message body.\r\n\r\n{*}Description / Explanation{*}:\r\n\r\nWhile a control channel POJO gives full control over the subscription or unsubscription, it would be more convenient to be able to send these messages from a routing participant by using URL parameters.\u00a0 Creating the control channel message for subscription looks like this:\r\n{code:java}\r\nDynamicRouterControlMessage billingSubMsg = new SubscribeMessageBuilder()\r\n                .id(\"billingSubscription\")\r\n                .channel(\"billing\")\r\n                .priority(10)\r\n                .endpointUri(myBillingNotificationUri)\r\n                .predicate(new SomeBillingPredicate())\r\n                .build(); {code}\r\nThen this is sent to the dynamic router control channel by:\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control\", billingSubMsg);{code}\r\nThe above could be simplified and combined by using the URI to specify the message:\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control/subscribe/billing?subscriptionId=billingSubscription&endpointUri=jms:billing&priority=10&predicate=${bodyAs(String)} regex '^\\\\d*[02468]$'\");{code}\r\nAlternatives can include:\r\n * Creating a {{Predicate}} as a bean, and referencing that bean as the {{predicate}}\r\n * Instantiating a {{Predicate}} and sending that predicate as the message body\r\n * Omitting the {{subscriptionId}} parameter, so that a subscription ID is generated and returned\r\n\r\nSimilarly, unsubscribing can be achieved by:\r\n\r\n\u00a0\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control/unsubscribe/billing?subscriptionId=billingSubscription);{code}\r\n\u00a0\r\n\r\n{*}Acceptance Criteria{*}:\r\n # Subscribing with all URI params:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component\r\n ** when: Routing participant sends empty message body to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\" and all other params\r\n ** then: Routing participant is subscribed with all supplied values\r\n # Unsubscribing:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, and routing participant has a valid subscription ID and channel name\r\n ** when: Routing participant sends empty message body to the dynamic router with the subscription URI beginning with \"dynamic-router:control/unsubscribe/\\{channel name}\" and the subscription ID\r\n ** then: Routing participant is unsubscribed for that channel and that subscription ID\r\n # Subscribing with URI params and Predicate bean:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, and a Predicate bean has been registered in the registry\r\n ** when: Routing participant sends an empty message to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\", the predicate parameter referencing the predicate bean, and all other params\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Subscribing with URI params and Predicate as message body:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component and a Predicate has been instantiated\r\n ** when: Routing participant sends an empty message to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\", and all other params, and the predicate instance is set as the message body\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Subscribing with control message POJO operates without change:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component and a control message POJO has been instantiated\r\n ** when: Routing participant sends subscribe POJO as message body to the control channel\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Unsubscribing with control message POJO operates without change:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, routing participant has a valid subscription ID and channel name,\u00a0 and a control message POJO for unsubscribing has been instantiated\r\n ** when: Routing participant sends unsubscribe POJO as message body to the control channel\r\n ** then:\u00a0Routing participant is unsubscribed for that channel and that subscription ID\r\n # Provide a mode to allow routing to all matching participants\r\n ** given: multiple subscribers with at least some overlapping filter predicates\r\n ** when: incoming messages match multiple recipients' filters\r\n ** then: all matching recipients receive a copy of the message\nFix up camel-spring-boot-examples caused by API changes here\r\nhttps://github.com/apache/camel-spring-boot-examples/commit/90e1c2aedda0fabced86e04ab9e622ee0628beca\n"}
{"GlobalId": 56, "code": "public void setAllowSerializedHeaders(boolean allowSerializedHeaders) {\n        this.allowSerializedHeaders = allowSerializedHeaders;\n    }", "comment": " This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level.", "commitId": "5dd59162e4ac9335e497934b8d662f598cb779d1", "issueId": "CAMEL-10666", "issueString": "Serializable headers lost by JmsBinding\nIn Camle 2.15.1 I was able to set a custom object in the header of my exchange and as long as it was serializable and the container consuming the route had this JVM options set (-Dorg.apache.activemq.SERIALIZABLE_PACKAGES=\"*\") and the queue had for both producer and consumer the option \"transferExchange=true\" everything was working fine.\n\nNow my company wanted to move to Camel 2.17.0.\nThe same code do not work anymore. All serializable objects in header are removed.\n\nTo make a simple example, there is not need to have a custom object, it can be a Calendar object.\n\n I decided to debug the code, and I noticed a big change in the org.apache.camel.impl.DefaultExchangeHolder class (camel-core). \n\nIt is used by the org.apache.camel.component.jms.JmsBinding#createJmsMessage(org.apache.camel.Exchange, java.lang.Object, java.util.Map<java.lang.String,java.lang.Object>, Session, org.apache.camel.CamelContext). Which is in camel-jms\n\nJmsBinding methos invoke DefaultExchangeHolder.marshal(echange)\n \nwhich is this:\n\npublic static DefaultExchangeHolder marshal(Exchange exchange) {\n\n   return marshal(exchange, true, false); <---- THE FALSE PARAMETER AVOID THE MARSHAL OF COMPLEX TYPE\n\n}\n\n \n\nIn Camel 2.1.5.1 the class is quite different and there is not any flag avoiding the serializable headers, or at list I did not see any.\n\n \nThis is a big change and it is not documented since if I look at the Camel page, it clearly states that if transferExchange is true than\n\n\"You can transfer the exchange over the wire instead of just the body and headers. The following fields are transferred: In body, Out body, Fault body, In headers, Out headers, Fault headers, exchange properties, exchange exception. This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level.\n\nYou must enable this option on both the producer and the consumer side, so Camel will know that the payload is an Exchange and not a regular payload.\"\n\n \n\nThere is any workaround in order to make this whole thing work as is should work? \n\n I know that there was a similar issue for levelDb\n\n\nhttps://issues.apache.org/jira/browse/CAMEL-9584\n\nThank you\n\nBarbara\nFor Fuse you need to ask to Red Hat support.\n\nAlso, for this kind of problem first use the users/dev mailing list.\n\nThanks.\nI ask red hat, don't know when they will answer.\n\nI also ask on mailing list: http://camel.465427.n5.nabble.com/Serializable-headers-lost-by-JmsBinding-td5792049.html\n\nIf I use pure camel I have the same problem, it is not related only to Fuse.\n\nCan you please consider to reopen this issue?\n\nThank you\nBarbara\nRe-opened after mailing list discussion.\nEdit description to use only camel components, not Fuse.\nI've sent a pull request to restore the possibility to send serializable headers within the exchange when using a JMS endpoint, simply setting to _true_ the new parameter _allowSerializedHeaders_ ( honored only when _transferExchange_ is _true_).\n\nPlease note that the serialization of _complex_ headers in JMS endpoints was available in 2.15 but removed in 2.16. Now it happens that FUSE 6.3.0 bundles a 2.17, so it would be great having a way to restore that feature in 2.17. That's why the fix was made on a branch forked from 2.17.x. \nThanks [~davide_cavestro]\n"}
{"GlobalId": 57, "code": "public void setGroupInstanceId(String groupInstanceId) {\n        this.groupInstanceId = groupInstanceId;\n    }", "comment": " A unique identifier of the consumer instance provided by the end user. Only non-empty strings are permitted. If set, the consumer is treated as a static member, which means that only one instance with this ID is allowed in the consumer group at any time. This can be used in combination with a larger session timeout to avoid group rebalances caused by transient unavailability (e.g. process restarts). If not set, the consumer will join the group as a dynamic member, which is the traditional behavior.", "commitId": "52b21ea9a49be30bd54beecf328e3b34a11ccfc6", "issueId": "CAMEL-16719", "issueString": "camel-kafka - Add option to configure group instance id\nhttps://camel.zulipchat.com/#narrow/stream/257298-camel/topic/Kafka.3A.20Group.20Instance.20id\r\n\r\n\r\nAdd this as endpoint option for the consumer\r\n\r\n    public static final String GROUP_INSTANCE_ID_CONFIG = \"group.instance.id\";\r\n    private static final String GROUP_INSTANCE_ID_DOC = \"A unique identifier of the consumer instance provided by the end user. Only non-empty strings are permitted. If set, the consumer is treated as a static member, which means that only one instance with this ID is allowed in the consumer group at any time. This can be used in combination with a larger session timeout to avoid group rebalances caused by transient unavailability (e.g. process restarts). If not set, the consumer will join the group as a dynamic member, which is the traditional behavior.\";\r\n\n"}
{"GlobalId": 61, "code": "public void setFileName(String fileName) {\n        if (fileName == null) {\n            throw new IllegalArgumentException(\"Parameter 'fileName' is null\");\n        }\n        this.fileName = fileName;\n    }", "comment": " Sets the file name for the literal data packet. The default value is \"_CONSOLE\". \"_CONSOLE\" indicates that the message is considered to be \"for your eyes only\". This advises that the message data is unusually sensitive, and the receiving program should process it more carefully, perhaps avoiding storing the received data to disk, for example.", "commitId": "dd8cbe5e55df23cb68525314f9a868b070c3c97d", "issueId": "CAMEL-8084", "issueString": "PGP Data Format: file name parameter\nCurrently, the PGP Data Format marshaler sets the file name of the PGP Literal Packet to \"_CONSOLE\" by default; and you can overwrite the file name via the header \"CamelFileName\". \n\nThe attached patch introduces the parameter \"fileName\" so that you can set the file name during configuration time. The default value is still \"_CONSOLE\". Now it is also possible to use an empty string as file name, which was not possible before. We should allow an empty string value because the Open PGP specification (https://tools.ietf.org/html/rfc4880) explicitly mentions that the file name \"may be a zero-length string\" (see chapter \"5.9.  Literal Data Packet (Tag 11)\".\n\nThe spec says about the \"_CONSOLE\" value: \"_CONSOLE\" is used to indicate that \" the message is considered to be 'for your eyes only'.  This advises that the message data is unusually sensitive, and the receiving program should process it more carefully, perhaps avoiding storing the received data to disk, for example.\" There are some PGP programs available which will break of the processing of PGP messages which contain the value \"_CONSOLE\" as file name. In order to avoid such kind of \"break-ofs\", it makes sense to allow the configuration of the file name via a parameter so that you must not use a header.\n\nRegards Franz\nApplied the patch into camel master branch with thanks to Franz, I also updated the wiki page for this new added option.\n"}
{"GlobalId": 62, "code": "public void setDefaultOfferTimeout(long defaultOfferTimeout) {\n        this.defaultOfferTimeout = defaultOfferTimeout;\n    }", "comment": " By enabling this option, where a configured timeout can be added to the block case. Utilizing the .offer(timeout) method of the underlining java queue", "commitId": "ef111092ccf8451e06e318ceae7e2f386eda9feb", "issueId": "CAMEL-12584", "issueString": "Allow seda producers to offer data to the queue with timeout\nThe seda producer only allows:\r\n * adding with possible exception if queue is full\r\n * blocking until space is available\r\n\r\nI'd like to suggest a third option for seda where a configured timeout can be added to the block case.\u00a0 Utilizing the .offer(timeout) method of the underlining java queue\r\n\r\nUse Case:\r\n\r\nI have a Apache NiFi system doing rest posts to my Apache Camel system.\u00a0 The camel system attempt to put the received message onto a seda queue which is backed by a SynchronousQueue.\u00a0 This causes an exception to occur if no threads are available to do the work requested, returns a service temporarily unavailable status to NiFi and Nifi pauses it's rest posts for a short delay.\u00a0\r\n\r\nI'd be able to save on some network traffic I/O if I was able to say try and wait 100ms before giving up on putting the data on the queue.\r\n\r\n\u00a0\r\n\r\nConcept of adding the \"offer/timeout\" was suggested in comments of CAMEL-1962\nSounds good, contributions is welcome\r\n\r\nhttps://github.com/apache/camel/blob/master/CONTRIBUTING.md\nlooking\n"}
{"GlobalId": 64, "code": "public ResequenceDefinition rejectOld() {\n        if (streamConfig == null) {\n            throw new IllegalStateException(\"rejectOld() only supported for stream resequencer\");\n        }\n        streamConfig.setRejectOld(true);\n        return this;\n    }", "comment": " Sets the rejectOld flag to throw an error when a message older than the last delivered message is processed", "commitId": "42cecd307825b1db02861957114300590dc5cc57", "issueId": "CAMEL-4327", "issueString": "Resequencer should include option to never deliver out-of-sequence messages\nIf the Resequencer EIP receives a message that precedes a message already delivered, the current behavior is to deliver the out-of-sequence message late. In some situations it is better to never pass a message on at all rather than pass on an out-of-sequence message. It would be useful to have an option to throw away late messages.\nI would not say to \"throw away\" late messages.  I would rather see an exception raised, so the developer can decide what to do with the message, e.g. route it to an endpoint dedicated to error processing, or drop it as you say.\nI agree, that's a good idea.\nSounds like a good idea.\nI assume this should apply to both batch & streaming mode, correct?  any thoughts on a good name for the option (alwaysOrdered, neverLate, etc)?\nI was writing this in the context of stream, and I think it makes the most sense in stream, but if it works in batch then might as well have the option.\n\nHow about rejectOld for the parameter? Sorry to be picky, but alwaysOrdered might imply that we'll never skip a message and neverLate hinges on your definition of \"late\". For example, you could still get a message 1 minute late... might be considered \"late\" for somebody!\nthanks David...I'll run with 'rejectOld' for now.  Also, I'll just support this in stream mode as the batch mode would require more invasive refactoring (BatchProcessor, etc).\nadded \"rejectOld\" option to the stream resequencer EIP...if set, it will throw an org.apache.camel.processor.resequencer.MessageRejectedException when a message older than the last delivered one is processed\n"}
{"GlobalId": 65, "code": "public DeadLetterChannelBuilder useOriginalExchange() {\n        setUseOriginalExchange(true);\n        return this;\n    }", "comment": " Will use the original input Exchange when an Exchange is moved to the dead letter queue. This allowsyou to store the original input in the dead letter queue instead of the inprogress snapshot of the IN body. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the Exchange again as the IN bodyis the same as when Camel received it. So you should be able to send the Exchange to the same input. By default this feature is off.", "commitId": "19ba32b3a328d06a1dcbee1eb662d380a4daf205", "issueId": "CAMEL-1600", "issueString": "DeadLetterChannel - add option for moving the original exchange to the dead letter queue instead of the current snapshot of the exchange\nIdea from an end user on the fuse forum:\nhttp://fusesource.com/forums/thread.jspa?messageID=2649&#2649\n\n    /**\n     * Will use the original input {@link Exchange} when an {@link Exchange} is moved to the dead letter queue.\n     * <p/>\n     * <b>Notice:</b> this only applies when all redeliveries attempt have failed and the {@link Exchange} is doomed for failure.\n     * <br/>\n     * Instead of using the current inprogress {@link Exchange} IN body we use the original IN body instead. This allows\n     * you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN body.\n     * For instance if you route transform the IN body during routing and then failed. With the original exchange\n     * store in the dead letter queue it might be easier to manually re submit the {@link Exchange} again as the IN body\n     * is the same as when Camel received it. So you should be able to send the {@link Exchange} to the same input.\n     * <p/>\n     * By default this feature is off.\n\n\nOh and as always {{onException}} could benefit as well. So lets add the option there as well, giving Camel end users the ultimate flexibility.\n\nBy default it will be _off_ in that sense it behaves as before. So you need explicit to enable it to use it.\ntrunk: 773801\n\nUpdated wiki as well. This feature exists for both *onException* and *deadLetterChannel*\n"}
{"GlobalId": 73, "code": "public WireTapDefinition<Type> copy(boolean copy) {\n        setCopy(copy);\n        return this;\n    }", "comment": " Uses a copy of the original exchange", "commitId": "f92c221f2600dfbd00ed3d8ba0e317bbaef2670f", "issueId": "CAMEL-5746", "issueString": "WireTap will always copy the origin Message\nI found the wiretap will always copy the original exchange message after deprecated those methods like -wireTap(String uri, boolean copy, Expression body)- and -wireTap(String uri, boolean copy, Processor processor)- .\n\nChecked the source code of *org.apache.camel.model.WireTapDefinition<Type>*, the *isCopy()* and *copy()* method are:\n{code}\n    public WireTapDefinition<Type> copy() {\n        setCopy(true);\n        return this;\n    }\n\n    public boolean isCopy() {\n        // should default to true if not configured\n        return copy != null ? copy : true;\n    }\n{code}\nSo, no matter, we use '.wireTap(\"XX\")' or '.wireTap(\"XX\").copy()' , it will always copy the original exchange message.\n\nWe could add a fluent to set if camel copy the origin Message.\nApplied the patch into trunk, camel-2.10.x and camel-2.9.x branches.\n"}
{"GlobalId": 75, "code": "public DelayDefinition delayTime(Long delay) {\n        setExpression(new ExpressionDefinition(ExpressionBuilder.constantExpression(delay)));\n        return this;\n    }", "comment": " Sets the delay time in millis to delay", "commitId": "597f54d38f590de8d00e76f7902dfa8d6795e791", "issueId": "CAMEL-1668", "issueString": "Delayer DSL in Spring XML is confusing to use\nTo wait 0.5 sec you should do\n\n{code}\n                <delay delayTime=\"500\">\n                    <constant/>\n                </delay>\n{code}\n\n{code}\nAnd not as expected:\n                <delay>\n                    <constant>500</constant>\n                </delay>\n{code}\n\ntrunk:\n\nNow its easier as it uses the expression to evaluate a delay in millis it will wait.\nNo more strange JMSTimestamp + 3000 stuff.\n\nAnd the Spring DSL does not have the delayTime attribute. So the delay is always in millis to wait from the current time.\n\nUpdated wiki as well.\nAnd a fix for Scala: 781733.\n"}
{"GlobalId": 83, "code": "public void setPriority(Integer priority) {\n        this.priority = priority;\n    }", "comment": " When sending messages to the control channel without using a DynamicRouterControlMessage, specify the subscription priority by using this URI param.", "commitId": "55addd015d17278e9133a9cc3ec628f4299c7b34", "issueId": "CAMEL-17500", "issueString": "Make dynamic router eip component subscription easier\n{*}User Story{*}:\r\n\r\nAs a user of the Dynamic Router EIP component, I want to be able to subscribe with URL parameters so that I am not required to create a control message POJO to send as the message body.\r\n\r\n{*}Description / Explanation{*}:\r\n\r\nWhile a control channel POJO gives full control over the subscription or unsubscription, it would be more convenient to be able to send these messages from a routing participant by using URL parameters.\u00a0 Creating the control channel message for subscription looks like this:\r\n{code:java}\r\nDynamicRouterControlMessage billingSubMsg = new SubscribeMessageBuilder()\r\n                .id(\"billingSubscription\")\r\n                .channel(\"billing\")\r\n                .priority(10)\r\n                .endpointUri(myBillingNotificationUri)\r\n                .predicate(new SomeBillingPredicate())\r\n                .build(); {code}\r\nThen this is sent to the dynamic router control channel by:\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control\", billingSubMsg);{code}\r\nThe above could be simplified and combined by using the URI to specify the message:\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control/subscribe/billing?subscriptionId=billingSubscription&endpointUri=jms:billing&priority=10&predicate=${bodyAs(String)} regex '^\\\\d*[02468]$'\");{code}\r\nAlternatives can include:\r\n * Creating a {{Predicate}} as a bean, and referencing that bean as the {{predicate}}\r\n * Instantiating a {{Predicate}} and sending that predicate as the message body\r\n * Omitting the {{subscriptionId}} parameter, so that a subscription ID is generated and returned\r\n\r\nSimilarly, unsubscribing can be achieved by:\r\n\r\n\u00a0\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control/unsubscribe/billing?subscriptionId=billingSubscription);{code}\r\n\u00a0\r\n\r\n{*}Acceptance Criteria{*}:\r\n # Subscribing with all URI params:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component\r\n ** when: Routing participant sends empty message body to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\" and all other params\r\n ** then: Routing participant is subscribed with all supplied values\r\n # Unsubscribing:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, and routing participant has a valid subscription ID and channel name\r\n ** when: Routing participant sends empty message body to the dynamic router with the subscription URI beginning with \"dynamic-router:control/unsubscribe/\\{channel name}\" and the subscription ID\r\n ** then: Routing participant is unsubscribed for that channel and that subscription ID\r\n # Subscribing with URI params and Predicate bean:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, and a Predicate bean has been registered in the registry\r\n ** when: Routing participant sends an empty message to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\", the predicate parameter referencing the predicate bean, and all other params\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Subscribing with URI params and Predicate as message body:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component and a Predicate has been instantiated\r\n ** when: Routing participant sends an empty message to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\", and all other params, and the predicate instance is set as the message body\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Subscribing with control message POJO operates without change:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component and a control message POJO has been instantiated\r\n ** when: Routing participant sends subscribe POJO as message body to the control channel\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Unsubscribing with control message POJO operates without change:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, routing participant has a valid subscription ID and channel name,\u00a0 and a control message POJO for unsubscribing has been instantiated\r\n ** when: Routing participant sends unsubscribe POJO as message body to the control channel\r\n ** then:\u00a0Routing participant is unsubscribed for that channel and that subscription ID\r\n # Provide a mode to allow routing to all matching participants\r\n ** given: multiple subscribers with at least some overlapping filter predicates\r\n ** when: incoming messages match multiple recipients' filters\r\n ** then: all matching recipients receive a copy of the message\nFix up camel-spring-boot-examples caused by API changes here\r\nhttps://github.com/apache/camel-spring-boot-examples/commit/90e1c2aedda0fabced86e04ab9e622ee0628beca\n"}
{"GlobalId": 84, "code": "public void setBindAddress(String bindAddress) {\n        this.bindAddress = bindAddress;\n    }", "comment": " Specifies the address of the local interface against which the connection should bind.", "commitId": "e7757e29b10fc55f97b92c2e7c77e69d5011fed4", "issueId": "CAMEL-12711", "issueString": "SFTP: Cannot specify bind address of local network interface\nIn an environment with multiple network interfaces, it might be necessary to specify the address of the local interface, to which the SFTP connection should bind.\u00a0Unfortunately, this is not possible with the\u00a0latest version of camel-ftp.\r\n\r\n\u00a0\r\n\r\nA new URI parameter 'bindAddress' should be introduces which can then be set to the IP-Address of the local network interface against which the SFTP connection should bind.\nThanks for reporting and the PR\n"}
{"GlobalId": 86, "code": "public String getSubscriptionId() {\n        return subscriptionId;\n    }", "comment": " When sending messages to the control channel without using a DynamicRouterControlMessage, specify the subscription ID by using this URI param.", "commitId": "55addd015d17278e9133a9cc3ec628f4299c7b34", "issueId": "CAMEL-17500", "issueString": "Make dynamic router eip component subscription easier\n{*}User Story{*}:\r\n\r\nAs a user of the Dynamic Router EIP component, I want to be able to subscribe with URL parameters so that I am not required to create a control message POJO to send as the message body.\r\n\r\n{*}Description / Explanation{*}:\r\n\r\nWhile a control channel POJO gives full control over the subscription or unsubscription, it would be more convenient to be able to send these messages from a routing participant by using URL parameters.\u00a0 Creating the control channel message for subscription looks like this:\r\n{code:java}\r\nDynamicRouterControlMessage billingSubMsg = new SubscribeMessageBuilder()\r\n                .id(\"billingSubscription\")\r\n                .channel(\"billing\")\r\n                .priority(10)\r\n                .endpointUri(myBillingNotificationUri)\r\n                .predicate(new SomeBillingPredicate())\r\n                .build(); {code}\r\nThen this is sent to the dynamic router control channel by:\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control\", billingSubMsg);{code}\r\nThe above could be simplified and combined by using the URI to specify the message:\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control/subscribe/billing?subscriptionId=billingSubscription&endpointUri=jms:billing&priority=10&predicate=${bodyAs(String)} regex '^\\\\d*[02468]$'\");{code}\r\nAlternatives can include:\r\n * Creating a {{Predicate}} as a bean, and referencing that bean as the {{predicate}}\r\n * Instantiating a {{Predicate}} and sending that predicate as the message body\r\n * Omitting the {{subscriptionId}} parameter, so that a subscription ID is generated and returned\r\n\r\nSimilarly, unsubscribing can be achieved by:\r\n\r\n\u00a0\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control/unsubscribe/billing?subscriptionId=billingSubscription);{code}\r\n\u00a0\r\n\r\n{*}Acceptance Criteria{*}:\r\n # Subscribing with all URI params:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component\r\n ** when: Routing participant sends empty message body to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\" and all other params\r\n ** then: Routing participant is subscribed with all supplied values\r\n # Unsubscribing:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, and routing participant has a valid subscription ID and channel name\r\n ** when: Routing participant sends empty message body to the dynamic router with the subscription URI beginning with \"dynamic-router:control/unsubscribe/\\{channel name}\" and the subscription ID\r\n ** then: Routing participant is unsubscribed for that channel and that subscription ID\r\n # Subscribing with URI params and Predicate bean:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, and a Predicate bean has been registered in the registry\r\n ** when: Routing participant sends an empty message to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\", the predicate parameter referencing the predicate bean, and all other params\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Subscribing with URI params and Predicate as message body:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component and a Predicate has been instantiated\r\n ** when: Routing participant sends an empty message to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\", and all other params, and the predicate instance is set as the message body\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Subscribing with control message POJO operates without change:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component and a control message POJO has been instantiated\r\n ** when: Routing participant sends subscribe POJO as message body to the control channel\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Unsubscribing with control message POJO operates without change:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, routing participant has a valid subscription ID and channel name,\u00a0 and a control message POJO for unsubscribing has been instantiated\r\n ** when: Routing participant sends unsubscribe POJO as message body to the control channel\r\n ** then:\u00a0Routing participant is unsubscribed for that channel and that subscription ID\r\n # Provide a mode to allow routing to all matching participants\r\n ** given: multiple subscribers with at least some overlapping filter predicates\r\n ** when: incoming messages match multiple recipients' filters\r\n ** then: all matching recipients receive a copy of the message\nFix up camel-spring-boot-examples caused by API changes here\r\nhttps://github.com/apache/camel-spring-boot-examples/commit/90e1c2aedda0fabced86e04ab9e622ee0628beca\n"}
{"GlobalId": 88, "code": "public void setApiContextRouteId(String apiContextRouteId) {\n        this.apiContextRouteId = apiContextRouteId;\n    }", "comment": " The route will by default use an auto assigned route id.", "commitId": "9ff11b57f5f5ea8efee195680617930d67d2c8d9", "issueId": "CAMEL-9251", "issueString": "rest-dsl - Allow to configure api-doc route id\nYou may want to be able to specify a route id as by default its an auto assigned route id.\n\nThere is a new apiContextRouteId option you can use to configure this.\n"}
{"GlobalId": 89, "code": "public void setEagerStopEngines(boolean eagerStopEngines) {\n        this.eagerStopEngines = eagerStopEngines;\n    }", "comment": " And when the route is started, then the engine is started again.", "commitId": "39986dd8021da5143ff81595de11d5841fdb6f4b", "issueId": "CAMEL-17190", "issueString": "camel-quickfix - Quickfix engine not stopped on route stop\nWhen route, consumed from quickfix, stopped (manually or by lost master status), quickfix-engine still works.\r\n\r\nFix messages are not processed by any camel route and there are no any exception's.\r\n\r\nIt seems that camel-quickfix-consumer should overvride doStop() like that:\r\n{code:java}\r\n@Override\r\nprotected void doStop() throws Exception {\r\n \u00a0 \u00a0(QuickfixjEndpoint)getEndpoint()).getEngine().doStop();\r\n    super.doStop(); \r\n} {code}\n3.4.x won't be released anymore. Please switch to 3.11.x the living LTS, we can eventually fix it there, not on 3.4.x\nOn 3.12.0 i have the same issue\nWhy do you think that, the engines are managed by the component and stopped when the component stops.\r\nAn engine can be shared to other consumers / routes etc. So you cannot just stop an engine in the consumer.\r\n\r\nHowever what seems to be missing is that if the consumer is stopped / started, then it should add/remove itself from the list of consumers on the endpoint, which is where the engine triggers when it has an event.\nAnother improvement is that if there are no more active consumers then the engine can be stopped eager, and if a consumer is started later, then the engine will be started again.\r\nOkay that is not as easy as the producers can also use the same engine, when they need to send messages.\nEngines are now stopped or start depending on any active consumer/producers using them\nYou can use the option eagerStopEngines on component to turn this off and have it work like before this change\n"}
{"GlobalId": 90, "code": "public void setMaxMessagesPerPoll(int maxMessagesPerPoll) {\n        this.maxMessagesPerPoll = maxMessagesPerPoll;\n    }", "comment": " To define a maximum messages to gather per poll. Can be used to set a limit of e.g. 1000 to avoid when starting up the server that there are thousands of files. Notice: If this option is in use then the limit will be applied on the valid files. For example if you have 100000 files and use maxMessagesPerPoll=500, then only the first 500 files will be picked up.", "commitId": "227c2b462a6d424ad5d17c075558bcb60d1451b2", "issueId": "CAMEL-14199", "issueString": "camel-hdfs - Add maxMessagesPerPoll for Consumer\nAdd a\u00a0_maxMessagesPerPoll_ property, like the file component has.\r\n\r\n\u00a0\r\n\r\n{color:#57d9a3}_* To define a maximum messages to gather per poll._{color}\r\n{color:#57d9a3} _* By default no maximum is set. Can be used to set a limit of e.g. 1000 to avoid when starting up the server that there are thousands of files._{color}\r\n{color:#57d9a3} _* Set a value of 0 or negative to disabled it._{color}\r\n{color:#57d9a3} _* Notice: If this option is in use then the File and FTP components will limit before any sorting._{color}\r\n{color:#57d9a3} _* For example if you have 100000 files and use maxMessagesPerPoll=500, then only the first 500 files will be picked up, and then sorted._{color}\n"}
{"GlobalId": 91, "code": "public OnExceptionDefinition useOriginalExchange() {\n        setUseOriginalExchangePolicy(Boolean.TRUE);\n        return this;\n    }", "comment": " Will use the original input org.apache.camel.Exchange when an org.apache.camel.Exchange is moved to the dead letter queue. This allowsyou to store the original input in the dead letter queue instead of the inprogress snapshot of the IN body. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN bodyis the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. By default this feature is off.", "commitId": "19ba32b3a328d06a1dcbee1eb662d380a4daf205", "issueId": "CAMEL-1600", "issueString": "DeadLetterChannel - add option for moving the original exchange to the dead letter queue instead of the current snapshot of the exchange\nIdea from an end user on the fuse forum:\nhttp://fusesource.com/forums/thread.jspa?messageID=2649&#2649\n\n    /**\n     * Will use the original input {@link Exchange} when an {@link Exchange} is moved to the dead letter queue.\n     * <p/>\n     * <b>Notice:</b> this only applies when all redeliveries attempt have failed and the {@link Exchange} is doomed for failure.\n     * <br/>\n     * Instead of using the current inprogress {@link Exchange} IN body we use the original IN body instead. This allows\n     * you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN body.\n     * For instance if you route transform the IN body during routing and then failed. With the original exchange\n     * store in the dead letter queue it might be easier to manually re submit the {@link Exchange} again as the IN body\n     * is the same as when Camel received it. So you should be able to send the {@link Exchange} to the same input.\n     * <p/>\n     * By default this feature is off.\n\n\nOh and as always {{onException}} could benefit as well. So lets add the option there as well, giving Camel end users the ultimate flexibility.\n\nBy default it will be _off_ in that sense it behaves as before. So you need explicit to enable it to use it.\ntrunk: 773801\n\nUpdated wiki as well. This feature exists for both *onException* and *deadLetterChannel*\n"}
{"GlobalId": 92, "code": "public void setRefreshToken(String refreshToken) {\n        this.refreshToken = refreshToken;\n    }", "comment": " The refresh token to refresh the access token for a specific Dropbox user", "commitId": "58f93dae69142999b965fbbd7d5945e3a4c5ea96", "issueId": "CAMEL-17941", "issueString": "Dropbox: long-lived access tokens are retired, must use refresh token\nThe API used to access dropbox currently only supports the parameter \"accesstoken\"\r\nfor ex. in the route:\r\n\r\n.to(\"dropbox://put?{*}accessToken{*}={{{{{}dropbox.accessToken{}}}}}\"\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 + \"&clientIdentifier={{{{{}dropbox.clientIdentifier{}}}}}\"\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 + \"&uploadMode=force\"\r\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 + \"&remotePath=/to_cellular{*}/{*}\")\r\n\r\n(by the way, the last '{*}/{*}' at remotePath is needed, otherwise the upload fails with '{*}KO{*}')\r\n\r\nAfter creating an access token inside the dropbox console and use it inside the route, the API works, but it will only work for {*}4 hours{*}, after that, the following error message will be thrown:\r\n\r\n{*}InvalidAccessTokenException{*}: {\"error_summary\":\u00a0\"{*}expired_access_token{*}/...\", \"error\": \\{\".tag\": \"expired_access_token\"}}\r\n\r\nDropbox did change their strategy and not supporting long-lived access tokens anymore.\r\n\r\nFrom the dropbox documentation: On September 30th, 2021, Dropbox will retire the creation of long-lived access tokens. Apps that require background (\u201coffline\u201d) access but have not yet implemented *refresh tokens* will be impacted.\r\n\r\n{*}Implement refresh tokens{*}: For apps that want to interact with the Dropbox API when a user isn\u2019t actively interacting with the app (\u201coffline\u201d access)\", we offer a long-lived refresh_token that can be used to request a new, short-lived access token.\r\n\r\nsee here: [https://dropbox.tech/developers/migrating-app-permissions-and-access-tokens]\r\n\r\nTherefore I think there must be an adjustment in the API Camel is using.\nI`ll take a look at this issue :)\u00a0\nI sent a PR to solve that.\nWe may need to backport this to 3.14.x so users of this version can keep using dropbox\n[~davsclaus] to backport this to 3.14.x should I check out the 3.14.x branch build a PR to there or should I apply some additional action?\n[~rhuanrcoha] It's the same process as for the main one, except that the target branch is the one we use for 3.14.x development instead of main.\r\n\r\nThanks for contributing this fix!\r\n\r\nEdit: more specifically, checkout the 3.14.x, cherry-pick/work on the change/etc, send a PR for that.\n"}
{"GlobalId": 94, "code": "public void setAbsolutePosition(int absolutePosition) {\n        this.absolutePosition = absolutePosition;\n    }", "comment": " This is only available for Java DSL.", "commitId": "2cd9d9d09a613ae8739cdd2affbdad91fa7a2768", "issueId": "CAMEL-12640", "issueString": "tooling - Provide character position in validation result\ncurrently the line start and line end are provided but not the character position\nWe have the absolute charachter position. We can look at trying to have both\r\n * absolute character position\r\n * relative character position on the begin line\nWhen using XML DSL then mind that the positions are referring to the position of the end of the XML tag (for single XML tags), eg where you have <.../>. This is how the XML parser does it. If you have both a start and end xml tag, then the position refers to the start tag.\r\n\r\nThe absolute position is only available for Java DSL.\r\n\r\n\u00a0\n"}
{"GlobalId": 98, "code": "public void setDestinationUri(final String destinationUri) {\n        this.destinationUri = destinationUri;\n    }", "comment": " When sending messages to the control channel without using a DynamicRouterControlMessage, specify the destination URI by using this URI param.", "commitId": "55addd015d17278e9133a9cc3ec628f4299c7b34", "issueId": "CAMEL-17500", "issueString": "Make dynamic router eip component subscription easier\n{*}User Story{*}:\r\n\r\nAs a user of the Dynamic Router EIP component, I want to be able to subscribe with URL parameters so that I am not required to create a control message POJO to send as the message body.\r\n\r\n{*}Description / Explanation{*}:\r\n\r\nWhile a control channel POJO gives full control over the subscription or unsubscription, it would be more convenient to be able to send these messages from a routing participant by using URL parameters.\u00a0 Creating the control channel message for subscription looks like this:\r\n{code:java}\r\nDynamicRouterControlMessage billingSubMsg = new SubscribeMessageBuilder()\r\n                .id(\"billingSubscription\")\r\n                .channel(\"billing\")\r\n                .priority(10)\r\n                .endpointUri(myBillingNotificationUri)\r\n                .predicate(new SomeBillingPredicate())\r\n                .build(); {code}\r\nThen this is sent to the dynamic router control channel by:\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control\", billingSubMsg);{code}\r\nThe above could be simplified and combined by using the URI to specify the message:\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control/subscribe/billing?subscriptionId=billingSubscription&endpointUri=jms:billing&priority=10&predicate=${bodyAs(String)} regex '^\\\\d*[02468]$'\");{code}\r\nAlternatives can include:\r\n * Creating a {{Predicate}} as a bean, and referencing that bean as the {{predicate}}\r\n * Instantiating a {{Predicate}} and sending that predicate as the message body\r\n * Omitting the {{subscriptionId}} parameter, so that a subscription ID is generated and returned\r\n\r\nSimilarly, unsubscribing can be achieved by:\r\n\r\n\u00a0\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control/unsubscribe/billing?subscriptionId=billingSubscription);{code}\r\n\u00a0\r\n\r\n{*}Acceptance Criteria{*}:\r\n # Subscribing with all URI params:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component\r\n ** when: Routing participant sends empty message body to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\" and all other params\r\n ** then: Routing participant is subscribed with all supplied values\r\n # Unsubscribing:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, and routing participant has a valid subscription ID and channel name\r\n ** when: Routing participant sends empty message body to the dynamic router with the subscription URI beginning with \"dynamic-router:control/unsubscribe/\\{channel name}\" and the subscription ID\r\n ** then: Routing participant is unsubscribed for that channel and that subscription ID\r\n # Subscribing with URI params and Predicate bean:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, and a Predicate bean has been registered in the registry\r\n ** when: Routing participant sends an empty message to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\", the predicate parameter referencing the predicate bean, and all other params\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Subscribing with URI params and Predicate as message body:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component and a Predicate has been instantiated\r\n ** when: Routing participant sends an empty message to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\", and all other params, and the predicate instance is set as the message body\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Subscribing with control message POJO operates without change:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component and a control message POJO has been instantiated\r\n ** when: Routing participant sends subscribe POJO as message body to the control channel\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Unsubscribing with control message POJO operates without change:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, routing participant has a valid subscription ID and channel name,\u00a0 and a control message POJO for unsubscribing has been instantiated\r\n ** when: Routing participant sends unsubscribe POJO as message body to the control channel\r\n ** then:\u00a0Routing participant is unsubscribed for that channel and that subscription ID\r\n # Provide a mode to allow routing to all matching participants\r\n ** given: multiple subscribers with at least some overlapping filter predicates\r\n ** when: incoming messages match multiple recipients' filters\r\n ** then: all matching recipients receive a copy of the message\nFix up camel-spring-boot-examples caused by API changes here\r\nhttps://github.com/apache/camel-spring-boot-examples/commit/90e1c2aedda0fabced86e04ab9e622ee0628beca\n"}
{"GlobalId": 100, "code": "public void setUseSystemProperties(boolean useSystemProperties) {\n\t\tthis.useSystemProperties = useSystemProperties;\n\t}", "comment": " To use System Properties as fallback for configuration", "commitId": "6c0b37a4f404f3df635f71069b82c3f8a38f4017", "issueId": "CAMEL-9831", "issueString": "Camel-http4: Make possible to use System Properties for configuration\nThere is case when we need to set for example http.nonProxyHosts property. The only way to set this on HttpClient is to use System Properties, but actually we instead read the proxy Properties from camelContext.\n\nWe can add an option useSystemProperties, that make possible to use System Properties as fallback.\n"}
{"GlobalId": 104, "code": "public void setOverrideHost(boolean overrideHost) {\n        this.overrideHost = overrideHost;\n    }", "comment": " Override the server reported endpoint host with the host from the endpoint URI.", "commitId": "daadfe77bdd62822347193f49bd22b8fddaf8646", "issueId": "CAMEL-12287", "issueString": "Allow overriding the server reported endpoint\nWhen the client connects to the server it asks the server first for available endpoints. The server should report back with a set of endpoints, which again contain the hostname to connect to.\r\n\r\nIf the server reports back with a hostname which the client cannot look up, it is currently not possible to connect to the server with camel-milo.\r\n\r\nI did prepare a PR which adds a boolean flag to the endpoint, allowing to override the host of reported endpoint with the one originally provided. This is disabled by default, but can be enabled when necessary.\n"}
{"GlobalId": 105, "code": "public void setSubscriptionId(final String subscriptionId) {\n        this.subscriptionId = subscriptionId;\n    }", "comment": " When sending messages to the control channel without using a DynamicRouterControlMessage, specify the subscription ID by using this URI param.", "commitId": "55addd015d17278e9133a9cc3ec628f4299c7b34", "issueId": "CAMEL-17500", "issueString": "Make dynamic router eip component subscription easier\n{*}User Story{*}:\r\n\r\nAs a user of the Dynamic Router EIP component, I want to be able to subscribe with URL parameters so that I am not required to create a control message POJO to send as the message body.\r\n\r\n{*}Description / Explanation{*}:\r\n\r\nWhile a control channel POJO gives full control over the subscription or unsubscription, it would be more convenient to be able to send these messages from a routing participant by using URL parameters.\u00a0 Creating the control channel message for subscription looks like this:\r\n{code:java}\r\nDynamicRouterControlMessage billingSubMsg = new SubscribeMessageBuilder()\r\n                .id(\"billingSubscription\")\r\n                .channel(\"billing\")\r\n                .priority(10)\r\n                .endpointUri(myBillingNotificationUri)\r\n                .predicate(new SomeBillingPredicate())\r\n                .build(); {code}\r\nThen this is sent to the dynamic router control channel by:\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control\", billingSubMsg);{code}\r\nThe above could be simplified and combined by using the URI to specify the message:\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control/subscribe/billing?subscriptionId=billingSubscription&endpointUri=jms:billing&priority=10&predicate=${bodyAs(String)} regex '^\\\\d*[02468]$'\");{code}\r\nAlternatives can include:\r\n * Creating a {{Predicate}} as a bean, and referencing that bean as the {{predicate}}\r\n * Instantiating a {{Predicate}} and sending that predicate as the message body\r\n * Omitting the {{subscriptionId}} parameter, so that a subscription ID is generated and returned\r\n\r\nSimilarly, unsubscribing can be achieved by:\r\n\r\n\u00a0\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control/unsubscribe/billing?subscriptionId=billingSubscription);{code}\r\n\u00a0\r\n\r\n{*}Acceptance Criteria{*}:\r\n # Subscribing with all URI params:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component\r\n ** when: Routing participant sends empty message body to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\" and all other params\r\n ** then: Routing participant is subscribed with all supplied values\r\n # Unsubscribing:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, and routing participant has a valid subscription ID and channel name\r\n ** when: Routing participant sends empty message body to the dynamic router with the subscription URI beginning with \"dynamic-router:control/unsubscribe/\\{channel name}\" and the subscription ID\r\n ** then: Routing participant is unsubscribed for that channel and that subscription ID\r\n # Subscribing with URI params and Predicate bean:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, and a Predicate bean has been registered in the registry\r\n ** when: Routing participant sends an empty message to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\", the predicate parameter referencing the predicate bean, and all other params\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Subscribing with URI params and Predicate as message body:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component and a Predicate has been instantiated\r\n ** when: Routing participant sends an empty message to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\", and all other params, and the predicate instance is set as the message body\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Subscribing with control message POJO operates without change:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component and a control message POJO has been instantiated\r\n ** when: Routing participant sends subscribe POJO as message body to the control channel\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Unsubscribing with control message POJO operates without change:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, routing participant has a valid subscription ID and channel name,\u00a0 and a control message POJO for unsubscribing has been instantiated\r\n ** when: Routing participant sends unsubscribe POJO as message body to the control channel\r\n ** then:\u00a0Routing participant is unsubscribed for that channel and that subscription ID\r\n # Provide a mode to allow routing to all matching participants\r\n ** given: multiple subscribers with at least some overlapping filter predicates\r\n ** when: incoming messages match multiple recipients' filters\r\n ** then: all matching recipients receive a copy of the message\nFix up camel-spring-boot-examples caused by API changes here\r\nhttps://github.com/apache/camel-spring-boot-examples/commit/90e1c2aedda0fabced86e04ab9e622ee0628beca\n"}
{"GlobalId": 106, "code": "public String getExpressionLanguage() {\n        return expressionLanguage;\n    }", "comment": " When sending messages to the control channel without using a DynamicRouterControlMessage, specify the expression language for creating the Predicate by using this URI param.", "commitId": "55addd015d17278e9133a9cc3ec628f4299c7b34", "issueId": "CAMEL-17500", "issueString": "Make dynamic router eip component subscription easier\n{*}User Story{*}:\r\n\r\nAs a user of the Dynamic Router EIP component, I want to be able to subscribe with URL parameters so that I am not required to create a control message POJO to send as the message body.\r\n\r\n{*}Description / Explanation{*}:\r\n\r\nWhile a control channel POJO gives full control over the subscription or unsubscription, it would be more convenient to be able to send these messages from a routing participant by using URL parameters.\u00a0 Creating the control channel message for subscription looks like this:\r\n{code:java}\r\nDynamicRouterControlMessage billingSubMsg = new SubscribeMessageBuilder()\r\n                .id(\"billingSubscription\")\r\n                .channel(\"billing\")\r\n                .priority(10)\r\n                .endpointUri(myBillingNotificationUri)\r\n                .predicate(new SomeBillingPredicate())\r\n                .build(); {code}\r\nThen this is sent to the dynamic router control channel by:\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control\", billingSubMsg);{code}\r\nThe above could be simplified and combined by using the URI to specify the message:\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control/subscribe/billing?subscriptionId=billingSubscription&endpointUri=jms:billing&priority=10&predicate=${bodyAs(String)} regex '^\\\\d*[02468]$'\");{code}\r\nAlternatives can include:\r\n * Creating a {{Predicate}} as a bean, and referencing that bean as the {{predicate}}\r\n * Instantiating a {{Predicate}} and sending that predicate as the message body\r\n * Omitting the {{subscriptionId}} parameter, so that a subscription ID is generated and returned\r\n\r\nSimilarly, unsubscribing can be achieved by:\r\n\r\n\u00a0\r\n{code:java}\r\ntemplate.sendBody(\"dynamic-router:control/unsubscribe/billing?subscriptionId=billingSubscription);{code}\r\n\u00a0\r\n\r\n{*}Acceptance Criteria{*}:\r\n # Subscribing with all URI params:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component\r\n ** when: Routing participant sends empty message body to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\" and all other params\r\n ** then: Routing participant is subscribed with all supplied values\r\n # Unsubscribing:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, and routing participant has a valid subscription ID and channel name\r\n ** when: Routing participant sends empty message body to the dynamic router with the subscription URI beginning with \"dynamic-router:control/unsubscribe/\\{channel name}\" and the subscription ID\r\n ** then: Routing participant is unsubscribed for that channel and that subscription ID\r\n # Subscribing with URI params and Predicate bean:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, and a Predicate bean has been registered in the registry\r\n ** when: Routing participant sends an empty message to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\", the predicate parameter referencing the predicate bean, and all other params\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Subscribing with URI params and Predicate as message body:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component and a Predicate has been instantiated\r\n ** when: Routing participant sends an empty message to the dynamic router with the subscription URI beginning with \"dynamic-router:control/subscribe/\\{channel name}\", and all other params, and the predicate instance is set as the message body\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Subscribing with control message POJO operates without change:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component and a control message POJO has been instantiated\r\n ** when: Routing participant sends subscribe POJO as message body to the control channel\r\n ** then:\u00a0Routing participant is subscribed with all supplied values\r\n # Unsubscribing with control message POJO operates without change:\r\n ** given: All necessary dependencies present for setting up a route with the dynamic router component, routing participant has a valid subscription ID and channel name,\u00a0 and a control message POJO for unsubscribing has been instantiated\r\n ** when: Routing participant sends unsubscribe POJO as message body to the control channel\r\n ** then:\u00a0Routing participant is unsubscribed for that channel and that subscription ID\r\n # Provide a mode to allow routing to all matching participants\r\n ** given: multiple subscribers with at least some overlapping filter predicates\r\n ** when: incoming messages match multiple recipients' filters\r\n ** then: all matching recipients receive a copy of the message\nFix up camel-spring-boot-examples caused by API changes here\r\nhttps://github.com/apache/camel-spring-boot-examples/commit/90e1c2aedda0fabced86e04ab9e622ee0628beca\n"}
{"GlobalId": 108, "code": "@Override\n    protected void doSuspend() {\n        pauseConsumers(pulsarConsumers);\n    }", "comment": " Pauses the Pulsar consumers. Once paused, a Pulsar consumer does not request any more messages from the broker.", "commitId": "b5aa05313c6997b457fdc4c6e8375b4279161133", "issueId": "CAMEL-17551", "issueString": "camel-pulsar: Pause Pulsar consumers when a Pulsar route is suspended\n*Proposed change*\r\n\r\nWhen a Pulsar route is suspended/resumed, the route's PulsarConsumer should pause() and resume() its Pulsar consumers.\r\n\r\n*Background*\r\n\r\nCamel's PulsarConsumer is not currently suspendable. When `suspend()` is called on a Pulsar endpoint/route, the route and its PulsarConsumer are stopped instead, which in the current implementation will stop+close the underlying Pulsar consumers.\r\n\r\nAs a result, in-flight exchanges cannot complete because the Pulsar consumers can't ack messages when in a closed state.\u00a0\r\n\r\nPulsar consumers can be paused and resumed instead. A paused Pulsar consumer does not request any more messages from the broker, but it can still communicate with the broker, for example to ack messages it's already received. (However, after calling .pause() on a Pulsar consumer, it will finish processing any messages that were buffered in its receiver queue \u2013 up to `receiverQueueSize` # of messages).\u00a0\nThanks for reporting and the PR\n"}
{"GlobalId": 110, "code": "public boolean isBodyOnly() {\n        return bodyOnly;\n    }", "comment": " Send only the message body", "commitId": "2e4fed914d52e1cd911fb2faf5c63e0cc1447d31", "issueId": "CAMEL-16540", "issueString": "camel-splunk - Include options to only send message body or headers\nh2. Problem\r\n\r\nsplunk-hec always sends the message body and headers under the static json keys \"body\" and \"headers\" respectively.\r\nh2. Solution\r\n\r\nInclude an option that defaults to the current behavior of sending the body and the headers.\r\n\r\nThese new options `bodyOnly` and `headersOnly` should send either the body or the headers. If both are true then prefer headers. This also removed the need to create a map with static keys.\r\nh2. Rationale\r\n # Including the headers makes searching more tedious and our queries must always be prefixed with `body.`.\r\n # Splunk charged based off of the amount of data you index. Indexing data you don't need can add up an unnecessary bill.\nI will be creating a PR shortly.\nI would like to add some interface that allows to plugin a custom implementation of what data to send. Then we can have a default implementation that can do the body only, headers only, or all as today.\r\n\r\nSince you pay per data, then users may want to plugin a custom implementation to filter out some headers (eg only header with keys starting with foo*), and only include exactly what they want. \n"}
{"GlobalId": 113, "code": "public boolean isHeadersOnly() {\n        return headersOnly;\n    }", "comment": " Send only message headers", "commitId": "2e4fed914d52e1cd911fb2faf5c63e0cc1447d31", "issueId": "CAMEL-16540", "issueString": "camel-splunk - Include options to only send message body or headers\nh2. Problem\r\n\r\nsplunk-hec always sends the message body and headers under the static json keys \"body\" and \"headers\" respectively.\r\nh2. Solution\r\n\r\nInclude an option that defaults to the current behavior of sending the body and the headers.\r\n\r\nThese new options `bodyOnly` and `headersOnly` should send either the body or the headers. If both are true then prefer headers. This also removed the need to create a map with static keys.\r\nh2. Rationale\r\n # Including the headers makes searching more tedious and our queries must always be prefixed with `body.`.\r\n # Splunk charged based off of the amount of data you index. Indexing data you don't need can add up an unnecessary bill.\nI will be creating a PR shortly.\nI would like to add some interface that allows to plugin a custom implementation of what data to send. Then we can have a default implementation that can do the body only, headers only, or all as today.\r\n\r\nSince you pay per data, then users may want to plugin a custom implementation to filter out some headers (eg only header with keys starting with foo*), and only include exactly what they want. \n"}
